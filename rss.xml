<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kevin.yang</title>
    <link>https://yanglukuan.github.io/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>博闻强记</description>
    <pubDate>Fri, 01 Sep 2017 01:36:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java集合框架之HashMap详解</title>
      <link>https://yanglukuan.github.io/2017/08/31/HashMap%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://yanglukuan.github.io/2017/08/31/HashMap%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Thu, 31 Aug 2017 05:21:13 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;基础扫盲&quot;&gt;&lt;a href=&quot;#基础扫盲&quot; class=&quot;headerlink&quot; title=&quot;基础扫盲&quot;&gt;&lt;/a&gt;基础扫盲&lt;/h2&gt;&lt;h3 id=&quot;java-集合框架&quot;&gt;&lt;a href=&quot;#java-集合框架&quot; class=&quot;headerlink&quot; title=
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="基础扫盲"><a href="#基础扫盲" class="headerlink" title="基础扫盲"></a>基础扫盲</h2><h3 id="java-集合框架"><a href="#java-集合框架" class="headerlink" title="java 集合框架"></a>java 集合框架</h3><hr>
<p><code>Java</code>的集合类主要由两个接口派生而出：<code>Collection</code>和<code>Map</code>，<code>Collection</code>和<code>Map</code>是<code>Java</code>集合框架的根接口，这两个接口又包含了一些接口或实现类。<code>Set</code>和<code>List</code>接口是<code>Collection</code>接口派生的两个子接口，<code>Queue</code>是<code>Java</code>提供的队列实现，类似于<code>List</code>。<code>Map</code>是一个映射接口，其中的每个元素都是一个<code>key-value</code>键值对，抽象类<code>AbstractMap</code>通过适配器模式实现了<code>Map</code>接口中的大部分函数，<code>TreeMap</code>、<code>HashMap</code>、<code>WeakHashMap</code>等实现类都通过继承<code>AbstractMap</code>来实现，另外，不常用的<code>HashTable</code>直接实现了Map接口。对于<code>Set</code>、<code>List</code>和<code>Map</code>三种集合，最常用的实现类分别是<code>HashSet</code>、<code>ArrayList</code>和<code>HashMap</code>三个实现类。</p>
<center><img src="/images/hashmap/javacollections.png" alt="Map接口类图"></center><center><strong><em>Map接口类图</em></strong></center>

<p>(1) HashMap：它根据键的<code>hashCode</code>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 <code>HashMap</code>最多只允许一条记录的键为<code>null</code>，允许多条记录的值为<code>null</code>。<code>HashMap</code>非线程安全，即任一时刻可以有多个线程同时写<code>HashMap</code>，可能会导致数据的不一致。如果需要满足线程安全，可以用 <code>Collections</code>的<code>synchronizedMap</code>方法使<code>HashMap</code>具有线程安全的能力，或者使用<code>ConcurrentHashMap</code>。<br>(2) <code>Hashtable</code>：<code>Hashtable</code>是遗留类，很多映射的常用功能与<code>HashMap</code>类似，不同的是它承自<code>Dictionary</code>类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如<code>ConcurrentHashMap</code>，因为<code>ConcurrentHashMap</code>引入了分段锁。<code>Hashtable</code>不建议在新代码中使用，不需要线程安全的场合可以用<code>HashMap</code>替换，需要线程安全的场合可以用<code>ConcurrentHashMap</code>替换。<br>(3) <code>LinkedHashMap</code>：<code>LinkedHashMap是HashMap</code>的一个子类，保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。<br>(4) <code>TreeMap</code>：<code>TreeMap</code>实现<code>SortedMap</code>接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code>遍历<code>TreeMap</code>时，得到的记录是排过序的。如果使用排序的映射，建议使用<code>TreeMap</code>。在使用<code>TreeMap</code>时，<code>key</code>必须实现<code>Comparable</code>接口或者在构造<code>TreeMap</code>传入自定义的<code>Comparator</code>，否则会在运行时抛出<code>java.lang.ClassCastException</code>类型的异常。</p>
<p>对于上述四种<code>Map</code>类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，<code>Map</code>对象很可能就定位不到映射的位置了。</p>
<h3 id="Hash-知识"><a href="#Hash-知识" class="headerlink" title="Hash 知识"></a>Hash 知识</h3><hr>
<p>维基百科的定义</p>
<blockquote>
<p>散列（英语：<code>Hashing</code>）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列。旧译哈希（误以为是人名而采用了音译）。它也常用作一种资讯安全的实作方法，由一串资料中经过散列算法（<code>Hashing algorithms</code>）计算出来的资料指纹（<code>data fingerprint</code>），经常用来识别档案与资料是否有被窜改，以保证档案与资料确实是由原创者所提供。</p>
</blockquote>
<h3 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h3><hr>
<blockquote>
<p>散列函数（或散列算法，又称哈希函数，英语：<code>Hash Function</code>）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（<code>hash values</code>，<code>hash codes</code>，<code>hash sums</code>，或<code>hashes</code>）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p>
</blockquote>
<p>上面是维基百科给出的定义，通俗点来讲，一般情况下，需要在关键字与它在表中的存储位置之间建立一个函数关系，以<code>f(key)</code>作为关键字为<code>key</code>的记录在表中的位置，通常称这个函数<code>f(key)</code>为哈希函数。</p>
<h3 id="哈希表和查找"><a href="#哈希表和查找" class="headerlink" title="哈希表和查找"></a>哈希表和查找</h3><hr>
<p>哈希表是哈希函数的一个主要应用，使用哈希表能够快速的按照关键字查找数据记录。（注意：关键字不是像在加密中所使用的那样是秘密的，但它们都是用来“解锁”或者访问数据的。）例如，在英语字典中的关键字是英文单词，和它们相关的记录包含这些单词的定义。在这种情况下，哈希函数必须把按照字母顺序排列的字符串映射到为哈希表的内部数组所创建的索引上。哈希表是一个在时间和空间上做出权衡的经典例子,在没有碰撞的情况下，检索时间复杂度为O(1)。</p>
<h3 id="Hash-冲突"><a href="#Hash-冲突" class="headerlink" title="Hash 冲突"></a>Hash 冲突</h3><hr>
<p>对不同的关键字可能得到同一散列地址，即 <code>k1!=k2</code>，而<code>f(k1)==f(k2)</code>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。解决碰撞有很多方法可以使用，最常用的包括链地址法和开地址法。<code>HashMap</code>就是用的链地址的方法解决冲突。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><hr>
<p><code>HashMap</code>是我们经常使用一个映射容器，通过牺牲存储空间来换取检索时间，<code>HashMap</code>是采用了hash表数据结构思想来实现。在<code>key</code>未发生冲突的情况下，搜索时间复杂度为O(1),可以快速定位元素。因此在日常开发中也被程序员广泛使用，例如作为关系映射容器、简单缓存、提高检索速度等。<code>HashMap</code>最多只允许一个键值为<code>null</code>(保存在数据列表中的第0个元素的链表上)，允许<code>value</code>为<code>null</code>值。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><hr>
<p><code>HashMap</code>实现了<code>Map</code>接口，继承<code>AbstractMap</code>。其中<code>Map</code>接口定义了键映射到值的规则，而<code>AbstractMap</code>类提供 <code>Map</code> 接口的骨干实现。<code>java</code>的<code>HashMap</code>结构上采用了数组链表方式，即数组+链表的数据结构，采用这种结构的原因是采用了链地址的方法解决哈希冲突。但是这样带来了一个问题，当某个链表达到一定的长度时，对于链表元素的查找会变成线性搜索，比较耗时。所以在<code>JDK1.8</code>的实现中做了优化，当链表的长度达到一定数量（<code>TREEIFY_THRESHOLD</code>默认值为8）时，会把链表转为红黑树，所以在<code>JDK1.8</code>的版本<code>HashMap</code>的数据结构为数组+链表+红黑树。<br>在<code>HashMap</code>中，通过<code>Node[] table</code>，(<code>jdk 1.7</code>叫做<code>Entry</code>，<code>jdk 1.8</code>加入红黑树后改为<code>Node</code>,原因是和红黑树的实现<code>TreeNode</code>相关联)来实现该结构，继承自<code>Map.Entry</code>，该数组可以看做是一个哈希桶数组，每个桶中存放着一个链表，Node是链表节点,并实现了<code>Map.Entry</code>。<code>Node</code>节点存放一个键值对，同时存放一个指向下一个节点的引用。<code>Node</code>是键值对存储单元，通过<code>hash</code>值来确定该元素在数组链表中的位置。基于这个存储结构，我们也可以看出，<code>HashMap</code>是不保证顺序性的，也就是说遍历<code>HashMap</code>的时候，得到的元素的顺序与添加元素的顺序是不同的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  Node结构源码</div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//用来定位数组索引位置，hash值不允许修改。</span></div><div class="line">        <span class="keyword">final</span> K key; <span class="comment">//key, 都是常数不允许修改。同时key是一个不可变对象。</span></div><div class="line">        V value;<span class="comment">//对应value</span></div><div class="line">        Node&lt;K,V&gt; next;<span class="comment">//下一个节点</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">this</span>.hash = hash;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line">        后面代码省略。。。。。。。。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<center><img src="/images/hashmap/hashmapstructure.png" alt="存储结构"></center><center><strong><em>存储结构</em></strong></center>

<h3 id="存取原理"><a href="#存取原理" class="headerlink" title="存取原理"></a>存取原理</h3><hr>
<p><strong>1.构造函数</strong><br>HashMap提供了四个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HashMap();<span class="comment">//构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</span></div><div class="line">HashMap(<span class="keyword">int</span> initialCapacity);<span class="comment">//构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</span></div><div class="line">HashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor);<span class="comment">//构造一个带指定初始容量和加载因子的空 HashMap。</span></div><div class="line">HashMap(Map&lt;? extendsK,? extendsV&gt; m); <span class="comment">//构造一个映射关系与指定 Map 相同的 HashMap。</span></div></pre></td></tr></table></figure></p>
<p>在这里出现了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中初始容量表示哈希表中桶的数量，也就是上一节提到的Node数组table[]的初始长度，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链地址法的散列表来说，查找一个元素的平均时间是<code>O(1+a)</code>，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。<br><strong>2.几个重要的属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. <span class="keyword">int</span> threshold; <span class="comment">// 所能容纳的key-value对极限</span></div><div class="line"><span class="number">2</span>. <span class="keyword">int</span> modCount; <span class="comment">// 修改次数</span></div><div class="line"><span class="number">3</span>. <span class="keyword">int</span> size; <span class="comment">// 元素数量</span></div><div class="line"><span class="number">4</span>. <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 负载因子</span></div></pre></td></tr></table></figure></p>
<p> <strong>threshold</strong><br><code>threshold</code>是<code>HashMap</code>所能容纳的最大数据量的<code>Node</code>(键值对)个数。<code>threshold = length * Load factor</code>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。如果容器中的元素数量超过这个值，那么<code>HashMap</code>就会进行扩容，重新调整元素位置。扩容后的容量是之前容量的2倍。在HashMap中容器的长度必须是2的倍数，这种设计主要是为了在取模和扩容时做优化，同时为了减少冲突，<code>HashMap</code>定位哈希桶索引位置时，也加入了高位参与运算的过程。<br> <strong>size</strong><br>这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度<code>length</code>、容纳最大键值对数量<code>threshold</code>的区别。<br> <strong>modCount</strong><br>字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。<br> <strong>TREEIFY_THRESHOLD</strong><br><code>static final int TREEIFY_THRESHOLD = 8;</code><br>在J<code>DK1.8</code>版本中，对数据结构做了进一步的优化，引入了红黑树。这是一个常数，表示链表长度的一个阈值。如果链表长度大于这个值(默认为8)时，就转为红黑树。利用红黑树提高增删改查的性能，避免之前因为某个链上积累太多元素而影响HashMap性能，使用红黑树使得增删改查等操作复杂度变为<code>O(logN)</code>。<br><strong>3.存取过程</strong><br><code>put</code>是<code>HashMap</code>的核心方法之一，用于存入数据，下面来分析下put方法的执行流程。</p>
<p><center><img src="/images/hashmap/hashmapput.png" alt="put方法执行顺序"></center><center><strong><em>put方法执行顺序</em></strong></center><br>根据分析，<code>put</code>方法的执行步骤如下：<br>1.首先判断<code>table</code>是否为null或者<code>length==0</code>,如果是则先做扩容<br>2.计算索引<br>根据键值<code>key</code>计算<code>hash</code>值在数组链表中的索引位置i。如果<code>key</code>为<code>null</code>,则默认保存到0位置的哈希桶，保证了一个<code>hashMap</code>中只有一个值为<code>null</code>的<code>key</code>。判断<code>table[i]</code>是否为空，如果为空则直接插入，执行。否则执行3。<br>3.判断<code>table[i]</code>的首个元素是否和key一样（通过<code>hashCode</code>以及<code>equals</code>判断），如果相同直接覆盖<code>value</code>，否则转向4。<br>4.判断<code>table[i]</code> 是否为treeNode(是否是红黑树)，如果是红黑树，则直接在树中插入键值对，否则转向5。<br>5.遍历<code>table[i]</code>，判断链表中是否存在相同的key,如果存在则直接覆盖。否则在链表尾部插入新节点（<code>JDK1.7</code>是在头部插入）。插入完成后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，遍历过程中若发现key已经存在直接覆盖value即可。<br>6.插入成功后，判断实际存在的键值对数量<code>size</code>是否超多了最大容量<code>threshold</code>，如果超过，进行扩容。</p>
<p>具体来看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//1.判断是否table为空</span></div><div class="line">        n = (tab = resize()).length;<span class="comment">//扩容</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//2.根据hash值计算索引，(n - 1) &amp; hash。判断该位置是否为空</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//插入新节点</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">//3.节点key存在 直接覆盖value</span></div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//4.判断是否为红黑树</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);<span class="comment">//红黑树 直接插入</span></div><div class="line">        <span class="keyword">else</span> &#123; <span class="comment">//5.链表操作</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//插入新节点</span></div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//判断是否存在相同的key 如果存在直接覆盖</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;  <span class="comment">//6.如果超过最大容量  扩容</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.HashCode的计算和元素定位</strong><br><code>HashMap</code>的数据结构决定了在整个使用过程包括增加、删除和查找元素时，定位到哈希桶数组的位置都是很关键的第一步。<code>hashMap</code>采用数组链表结构，我们希望插入的元素在表中尽可能的均匀分布，这样能够提高操作效率。而元素的分布情况与<code>hashCode</code>计算算法有关，直接影响<code>hash</code>离散性能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 计算hash值</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 </span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">    可以看作两步：</span></div><div class="line"><span class="comment">    1.   h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line"><span class="comment">    2.   h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line"><span class="comment">     **/</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 锁定数组下标位置(锁定hash桶)</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，直接在代码中用(n - 1) &amp; hash替代，实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定位哈希桶数组分为两个大步骤： </p>
<ol>
<li>计算<code>hash</code>值(取<code>key</code>的<code>hashCode</code>值、高位运算) </li>
<li>根据<code>hash</code>值定位哈希数组位置<br>在数据结构学习中，计算哈希桶数组位置的常用方式就是取模运算，即<code>index = hash% length</code>。通过这种方式可以使得每个元素能够相对均匀的分布在哈希桶数组中，<code>java</code>中的<code>hash</code>也采用了类似的方式。为了提高计算性能，<code>java</code>采用了&amp;计算代替取模。前面我们提到哈希桶数组的长度是2倍数，这个设置是为了对<code>hashMap</code>中的操作进行优化。<br>比如4的二进制是100， 对<code>4</code>取模操作<code>5%4 = 1</code>相当于 <code>101 &amp; 011 = 001 等于1</code>。在《剑指offer》中“二进制中的1的个数”也巧妙运用了<code>n&amp;(n-1)</code>计算整数中出现1的个数。<br>一个<code>hashCode</code>是32位，而如果哈希桶数组长度比较小时，直接对hashCode进行取模运算只考虑了hashCode的低位字节。Java中同时考虑了高位和低位在计算索引位置的作用，保证高地位Bit都能参与到Hash的计算中。在<code>JDK1.8</code>的实现中，优化了高位运算的算法，通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，也保证数组<code>table</code>的<code>length</code>比较小的时候，高低<code>Bit</code>都能参与进来，使得元素更加均匀分散。<br><center><img src="/images/hashmap/hashmaphash.png" alt="Hash计算方式"></center><center><strong><em>Hash计算方式</em></strong></center><br><strong>5.插入元素</strong><br>当元素定位的哈希桶是一个链表时，则采用尾插入法。首先从头遍历链表，根据<code>equals</code>和<code>hashCode</code>来比较<code>key</code>是否相同。因此作为<code>hashMap</code>的<code>key</code>必须同时重载<code>equals</code>方法和<code>hashCode</code>方法。<br><code>JDK 1.7</code>的链表操作采用了头插入法，即新的元素插入到链表头部。在J<code>DK1.8</code>中采用了尾插入法。插入以后如果链表长度大于8，那么就会将链表转换为红黑树。因为如果链表长度过长会导致元素的增删改查效率低下，呈现线性搜索时间。<code>JDK1.8</code>采用采用红黑树进行优化，进而提高<code>HashMap</code>性能。如果哈希桶是一个红黑树，则直接使用红黑树插入方式直接插入到红黑树中。<br><strong>6.扩容</strong><br><code>JDK1.8</code>是在插入元素后判断是否进行扩容，而且扩容条件相对于<code>JDK1.7</code>有所变化。<code>JDK1.7</code>是在插入元素前判断是否需要扩容，不仅要求<code>size</code>大于等于<code>threshold</code>，同时需要<code>table[bucketIndex]</code>不为空时才进行扩容。扩容时新的容器容量是原来的两倍。<code>JDK1.8</code>对于扩容过程进行了优化，提高扩容性能。<br><code>JDK 1.7</code>是通过创建一个容量为原来两倍的新容器，然后遍历原来容器的所有元素并对每个元素重新计算一次在新容器的索引位置，然后插入到新容器中。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/qq_27093465/article/details/52209789" target="_blank" rel="external">http://blog.csdn.net/qq_27093465/article/details/52209789</a><br><a href="http://blog.csdn.net/qq_27093465/article/details/52207152" target="_blank" rel="external">http://blog.csdn.net/qq_27093465/article/details/52207152</a><br><a href="http://www.importnew.com/16599.html" target="_blank" rel="external">http://www.importnew.com/16599.html</a><br><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">https://tech.meituan.com/java-hashmap.html</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/31/HashMap%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SOA简述</title>
      <link>https://yanglukuan.github.io/2017/08/24/%E6%9E%B6%E6%9E%84/SOA%E7%AE%80%E8%BF%B0/</link>
      <guid>https://yanglukuan.github.io/2017/08/24/%E6%9E%B6%E6%9E%84/SOA%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 24 Aug 2017 03:25:07 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;混沌&quot;&gt;&lt;a href=&quot;#混沌&quot; class=&quot;headerlink&quot; title=&quot;混沌&quot;&gt;&lt;/a&gt;混沌&lt;/h2&gt;&lt;p&gt;接触&lt;code&gt;SOA&lt;/code&gt;也有几年时间了，从未对其概念和模式深究。我们总是对自己每天接触的东西习以为常，甚至视而不见。随着互联网的
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="混沌"><a href="#混沌" class="headerlink" title="混沌"></a>混沌</h2><p>接触<code>SOA</code>也有几年时间了，从未对其概念和模式深究。我们总是对自己每天接触的东西习以为常，甚至视而不见。随着互联网的发展，<code>SOA</code>的架构也随之大行其道，随之而来的是各种高大上的架构模型和技术名称，林林总总让人眼花缭乱。一直以来对这些都是模糊的概念，想去深究也屡不出个头绪。最近看了几篇业界大牛的文章，略有感悟，试着整理下思路，理清一些基本的概念和术语。本文侧重以自己的理解描述<code>SOA</code>是什么以及由<code>SOA</code>衍生而来的各种技术名词和他们之间的关系，不会详细阐述<code>SOA</code>的原理和<code>SOA</code>架构的各种实践。</p>
<h2 id="开悟"><a href="#开悟" class="headerlink" title="开悟"></a>开悟</h2><h3 id="SOA定义"><a href="#SOA定义" class="headerlink" title="SOA定义"></a>SOA定义</h3><ul>
<li><p>先来一段维基百科对<code>SOA</code>的描述</p>
<blockquote>
<p>面向服务的体系结构（英语：<code>service-oriented architecture</code>）是构造分布式计算的应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。它采用开放标准、与软件资源进行交互并采用表示的标准方式。</p>
</blockquote>
<p>怎么样，多么标准的教科书般的定义。不过这个定义未免太过抽象，我们试着从实质的内容来阐述一下，<code>SOA</code>的出现是为了解决一种什么样的问题或者他规定了什么内容。</p>
</li>
<li><p>感性的<code>SOA</code>定义<br><code>SOA</code>不是一种技术，也不是一个标准，而是一种架构方式，包含了服务提供者、服务调用者、服务管理中心等角色，整个架构模式也是围绕着这些角色如何更有效的互相配合，从而实现<code>SOA</code>架构的商业价值。<code>SOA</code>的应用已经非常普及，毕竟从诞生到现在已经二十余年了。1996年由<code>Gartner</code>公司提出，后经过<code>IBM</code>、<code>SUN</code>、<code>BEA</code>、<code>Oracle</code>等公司完善和推广，<code>SOA</code>的思想和理论逐步得到完善。不管是从概念模型上还是具体应用技术上，都已经得到了全面的发展，也衍生出了很多的新的概念和技术,比如<code>HTTP API</code>,云服务，敏捷开发，持续交付，<code>DevOps</code>等，这些技术的发展和成熟也推动着SOA架构的不断演变。</p>
<h3 id="SOA理念"><a href="#SOA理念" class="headerlink" title="SOA理念"></a>SOA理念</h3><p><code>SOA</code>要求开发者从服务集成的角度来设计应用软件，目标为了提高重用性,即使这么做的利益不会马上显现。<code>SOA</code>要求开发者超越应用软件来思考，并考虑复用现有的服务，或者检查如何让服务被重复利用。<code>SOA</code>鼓励使用可替代的技术和方法（例如消息机制），通过把服务联系在一起而非编写新代码来构架应用。</p>
<h3 id="SOA原则"><a href="#SOA原则" class="headerlink" title="SOA原则"></a>SOA原则</h3><p>服务松耦合(<code>Loosely coupled</code>) - 服务之间的关系最小化，只是互相知道。<br>服务契约 - 服务按照服务描述文档所定义的服务契约行事。<br>服务抽象 - 除了服务契约中所描述的内容，服务将对外部隐藏逻辑。<br>服务的重用性 - 将逻辑分布在不同的服务中，以提高服务的重用性。<br>服务的可组合性 - 一组服务可以协调工作并组合起来形成一个组合服务。<br>服务自治 – 服务对所封装的逻辑具有控制权<br>服务无状态 – 服务将一个活动所需保存的资讯最小化。<br>服务的可被发现性 – 服务需要对外部提供描述资讯，这样可以通过现有的发现机制发现并访问这些服务。</p>
</li>
</ul>
<blockquote>
<p>这样，我们对<code>SOA</code>有了一个感性的了解，我们可以这样认为，<code>SOA</code>其实就是利用模块化思维，遵循<code>SOA</code>定义的原则构建分布式应用的架构模式，基于这个理解下面我们再来看一下在<code>SOA</code>架构下的实现方式。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><p><code>Web Service</code>相信大家对这个名词也不是很陌生吧，不过令人遗憾的是这个现在已经被滥用的太严重了，以至于我们不能清晰的描述出<code>Web Service</code>到底是什么。老规矩，根据维基百科定义<strong>Web服务是一种服务导向架构的技术，通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作。</strong> 其实，一般情况下可以认为<code>Web service</code> 是<code>SOA</code>架构的一个实例，通常使用HTTP协议，一般使用<code>web</code>服务器作为服务请求的管道。</p>
<ul>
<li><p><strong><code>Web Service</code>要素</strong></p>
<ul>
<li><p><code>SOAP</code><br>提到<code>Web Service</code>,不得不说到的就是<code>SOAP</code>了。<code>SOAP</code>（原为<code>Simple Object Access Protocol</code>的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，一个基于<code>XML</code>的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是<code>HTTP</code>或<code>HTTPS</code>，但也可能是<code>SMTP</code>或<code>XMPP</code>。</p>
</li>
<li><p><code>WSDL</code><br><code>WSDL (Web Service Description Language)</code>也遵循<code>XML</code>格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。</p>
</li>
<li><code>UUID</code><br>一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务。</li>
</ul>
</li>
<li><p><strong>不同厂商的实现</strong><br>不同的厂商根据又发展了自己的协议和实现方式</p>
<ul>
<li>java<br><code>Java API for XML Web Services（JAX-WS）</code>是<code>Java</code>程序设计语言一个用来创建<code>Web</code>服务的<code>API</code></li>
<li>.NET<br>.<code>NET WebService</code>、<code>NET Remoting</code>、<code>WCF</code></li>
</ul>
</li>
<li><p><strong>Web Service 使用</strong><br>使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。不过现在为了简化调用过程，又有了新的使用方式，就是舍弃一部分或者完全舍弃SOAP协议，使用HTTP+去掉头尾的SOAP或者HTTP+JSON的方式调实现web service,这种更加轻量的方式又叫做rest方式调用。</p>
</li>
</ul>
<h3 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h3><ul>
<li><strong>又又又来一个新名词</strong></li>
</ul>
<blockquote>
<p>REST（英文：Representational State Transfer，又称具象状态传输）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。说到底，REST也只是一种架构风格，而不是协议或标准。但这种新的风格对现有的以SOAP为代表的Web Service造成的冲击也是革命性的，因为它面向资源，甚至连服务也抽象成资源，它和HTTP紧密结合，是无状态的。</p>
</blockquote>
<p>传统意义上的rest可能要和soa划在一个层面，都是软件架构的方式，soa是面向服务的软件架构方式，Rest是面向资源的软件架构方式，不过事实上，一些Web Service提供者提供的REST API只有REST的外壳，传输的请求和应答全然是简化了的SOAP，这种新瓶装旧酒的做法只是加深了标准的分歧而已。归根结底REST无法简单地解决一些问题，因此我们只能看到SOAP在REST外壳下的借尸还魂。所以目前rest还是划分到webservice下的一个使用方式的分支，用以区分以soap为协议的传统webservice的调用方法。</p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="分布式异构系统的通信"><a href="#分布式异构系统的通信" class="headerlink" title="分布式异构系统的通信"></a>分布式异构系统的通信</h3><p>上面说到了SOA是构建模块化的分布式系统的架构模式，既然提到了分布式，那不得不说的就是基于分布式的模式下各个系统或者模块间的通信了。SOA建立在分布式和异构平台下，分布式程序的基础是RPC调用，RPC的本质是网络传输和对象序列化，需要用RPC在分布式和异构系统中进行通信。当然这只一种选择，还可以选择比如基于message的方式进行通讯和集成，这里就不展开说明了。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><blockquote>
<p>维基百科对于RPC的定义<br>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。</p>
</blockquote>
<ul>
<li><strong>RPC目标</strong><br>RPC的主要目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</li>
<li><strong>RPC性能</strong><br>不过RPC是跨进程进行调用，如果在进程内进行方法调用，所需的时间量级是 ns（纳秒）级，而进程间的RPC方法调用时间量级通常是 ms（毫秒）级，它们之间有着10的六次方的效率之差，所以选择这只方式进行通讯意味着要要牺牲一定的性能，而且一般在这种架构下完成一个功能或者一个接口可能需要多次的RPC调用，这就要求我们在实现接口是特别注意性能问题，一点点的性能差异在这种架构下都会被放大。</li>
</ul>
<h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><h3 id="业界主流框架"><a href="#业界主流框架" class="headerlink" title="业界主流框架"></a>业界主流框架</h3><p>上面提到针对<code>SOA</code>的实现，各大厂商都提供了自己的技术实现和一整套的解决方案，但是在大规模异构的分布式系统中，还是希望能有一个比较统一的框架来实现各种异构系统的通信和集成，这个时候，就有了各种<code>RPC</code>框架，或者叫服务框架。一般分为两种，一种是比较狭义的<code>RPC</code>框架，属于轻量级框架，仅具备完整的<code>RPC</code>调用功能（比如像<code>thrift</code>、<code>gRPC</code>等），在各种复杂的架构和业务场景下，这种框架显得有些捉襟见肘，不具备比如调用监控、服务路由等功能。这时候，又衍生出了另外一种框架，分布式服务框架，包括<code>RPC</code>调用、服务治理、注册发现、流量切换、服务路由、多传输协议、多序列化协议等各种复杂的功能，使得<code>SOA</code>架构下的分布式系统具备高可用的能力。</p>
<h3 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h3><p><code>CORBAR</code>为了解决异构平台的<code>RPC</code>，使用了<code>IDL（Interface Definition Language）</code>来定义远程接口，并将其映射到特定的平台语言中。后来大部分的跨语言平台<code>RPC</code>基本都采用了此类方式，比如我们熟悉的<code>Web Service（SOAP）</code>，近年开源的 <code>Thrift</code>等。他们大部分都通过<code>IDL</code>定义，并提供工具来映射生成不同语言平台的<code>user-stub</code>和<code>server-stub</code>，并通过框架库来提供<code>RPCRuntime</code>的支持。不过貌似每个不同的<code>RPC</code>框架都定义了各自不同的<code>IDL</code>格式，导致程序员的学习成本进一步上升，<code>Web Service</code>尝试建立业界标准，无赖标准规范复杂而效率偏低，否则<code>Thrift</code>等更高效的<code>RPC</code>框架就没必要出现了。<code>IDL</code> 是为了跨平台语言实现<code>RPC</code>不得已的选择，要解决更广泛的问题自然导致了更复杂的方案。而对于同一平台内的 RPC 而言显然没必要搞个中间语言出来，例如<code>Java</code>原生的<code>RMI</code>，这样对于<code>java</code>程序员而言显得更直接简单，降低使用的学习成本。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mindwind/p/5518145.html" target="_blank" rel="external">http://www.cnblogs.com/mindwind/p/5518145.html</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84</a><br><a href="http://www.baike.com/wiki/SOA%E6%9E%B6%E6%9E%84" target="_blank" rel="external">http://www.baike.com/wiki/SOA%E6%9E%B6%E6%9E%84</a><br><a href="https://segmentfault.com/q/1010000003049016" target="_blank" rel="external">https://segmentfault.com/q/1010000003049016</a><br><a href="http://www.infoq.com/cn/articles/micro-soa-2?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">http://www.infoq.com/cn/articles/micro-soa-2?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link</a><br><a href="http://www.infoq.com/cn/articles/micro-soa-1?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">http://www.infoq.com/cn/articles/micro-soa-1?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link</a><br><a href="http://itindex.net/detail/51931-soa-api-%E5%88%86%E8%A3%82" target="_blank" rel="external">http://itindex.net/detail/51931-soa-api-%E5%88%86%E8%A3%82</a><br><a href="http://www.cnblogs.com/zhangz721/archive/2009/10/02/1577316.html" target="_blank" rel="external">http://www.cnblogs.com/zhangz721/archive/2009/10/02/1577316.html</a></p>
<p><strong> 如若在茫茫宇宙中窥见了一丝真理，那该是何等之幸事。</strong></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/24/%E6%9E%B6%E6%9E%84/SOA%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Servlet和JSP</title>
      <link>https://yanglukuan.github.io/2017/08/22/java/JSP%E5%92%8CServlet/</link>
      <guid>https://yanglukuan.github.io/2017/08/22/java/JSP%E5%92%8CServlet/</guid>
      <pubDate>Tue, 22 Aug 2017 05:07:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;在我们面试的时候一般会被问到，”Servlet和JSP有什么区别和联系？”。那么今天我们就来回答一下这个问题，顺便复习一下Servlet和JSP的一些相关知识。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;JSP&quot;&gt;&lt;a href=&quot;#JSP&quot; class=&quot;headerlink&quot; 
      
      </description>
      
      <content:encoded><![CDATA[<p>在我们面试的时候一般会被问到，”Servlet和JSP有什么区别和联系？”。那么今天我们就来回答一下这个问题，顺便复习一下Servlet和JSP的一些相关知识。</p>
<hr>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="出现"><a href="#出现" class="headerlink" title="出现"></a>出现</h3><blockquote>
<p>JSP（全称JavaServer Pages）是由Sun Microsystems公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成HTML、XML或其他格式文档的Web网页的技术标准。JSP技术是以Java语言作为脚本语言的，JSP网页为整个服务器端的Java库单元提供了一个接口来服务于HTTP的应用程序。从架构上说，JSP可以被看作是从Servlets高级提炼而作为JAVA Servlet 2.1 API的扩展而应用。Servlets和JSP最早都是由Sun Microsystems（太阳公司）开发的。</p>
</blockquote>
<p>随着大量的B/S架构程序开发出来以后，人们发现Servlet类的编写是非常繁琐的，主要集中在几个问题上：首先有大量冗余代码，这些代码在每个servlet类中都是一模一样或者基本近似的，其次是开发Servlet的程序员很少有精通美工的，导致使用Servlet开发无法方便的做到各种页面效果和丰富多彩的风格，这个时候sun借鉴了微软的ASP方式，正式提出JSP（也就是Servlet 1.1），JSP推出后，JAVA程序员也能象ASP的程序员那样将服务端代码添加在已经由美工设计好的静态页面上，经过一个JSP容器对JSP文件进行自动解析并转换成Servlet类来交给WEB服务器运行。这么一来，极大的提高了工作效率。</p>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>当客户端浏览器向服务器请求一个 JSP 页面时，服务器收到该请求后，首先检查所请求的这个JSP 文件内容 ( 代码 ) 是否已经被更新，或者是否是 JSP 文件创建后的第一次被访问，如果是，那么，这个 JSP 文件就会在服务器端的 JSP 引擎作用下转化为一个 Servlet 类的 Java 源代码文件。紧接着，这个 Servlet 类会在 Java 编译器的作用下被编译成一个字节码文件，并装载到 jvm 解释执行。剩下的就等同于 Servlet 的处理过程了。如果被请求的 JSP 文件内容 ( 代码 ) 没有被修改，那么它的处理过程也等同于一个 Servlet 的处理过程。即直接由服务器检索出与之对应的Servlet 实例来处理。一种是预编译，也就是当Tomcat启动的时候，所有部署的应用中的jsp都会进行编译，另外一种是当第一次访问的时候对该jsp进行编译；无论是哪一种，JSPCompilationContext都是编译的上下文，JSPServletWrapper通过JSPCompilationContext进行加载jsp源文件，然后调用对应的Compiler进行编译为servlet的class，并通过JasperLoader进行加载。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。最早支持Servlet标准的是JavaSoft的Java Web Server。此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p>
<h3 id="Servlet规范"><a href="#Servlet规范" class="headerlink" title="Servlet规范"></a>Servlet规范</h3><p><a href="http://ognvcf5x6.bkt.clouddn.com/bbs_image/Servlet3.1%E8%A7%84%E8%8C%83.pdf" target="_blank" rel="external">Servlet规范</a></p>
<h3 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h3><p>Servlet容器是web server或application server的一部分，提供基于请求/响应发送模型的网络服务，解码基于MIME的请求，并且格式化基于MIME的响应。Servlet 容器也包含了管理Servlet生命周期。Servlet容器可以嵌入到宿主的web server中，或者通过Web Server的本地扩展API单独作为附加组件安装。Servelt容器也可能内嵌或安装到包含web功能的application server中。所有Servlet容器必须支持基于HTTP协议的请求/响应模型，比如像基于HTTPS（HTTP over SSL）协议的请求/应答模型可以选择性的支持。容器必须实现的HTTP协议版本包含HTTP/1.0 和 HTTP/1.1。因为容器或许支持RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给Servlet处理之前修改它们，也可能在将Servlet生成的响应发送给客户端之前修改它们，或者可能根据RFC2616规范直接对请求作出响应而不交给Servlet进行处理。Servlet容器应该使Servlet执行在一个安全限制的环境中。在Java平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在Java平台定义的安全许可架构中。比如，高端的application server为了保证容器的其他组件不受到负面影响可能会限制Thread对象的创建。Java SE 6是构建Servlet容器最低的Java平台版本。</p>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>1、在servlet容器或web server启动时，对servlet进行实例化，此时调用servlet的构造方法；servlet实例化后，调用该servlet实例的init方法，对servlet进行一些初始化处理，处理完成后，将该servlet注入到servlet容器中;<br>2、当client向web server或servlet容器请求servlet时，web server或servlet容器首先会根据请求的servlet名称去servlet容器中找对应的servlet，如果servlet不存在该名称对应的servlet，则向client响应请求不存在等信息，否则进行步骤3；<br>3、如果请求的servlet存在于servlet容器，则调用servlet的service方法，生成动态资源，响应给client; （记住，整个过程该servlet只有一个实例，即单例）；<br>4、当web server退出或servlet容器销毁时，调用servlet的destroy方法，最后唯一的sevlet实例将会被GC。<br>在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的init()和destroy()方法都只进行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的service()方法，为接收到的请求服务。servlet只会实例化一次，servlet容器启动时或者第一次处理请求时之后所有请求都只共享这一个实例，每个请求对应一个线程去处理，线程池方式处理JSP/Servlet容器默认是采用单实例多线程(这是造成线程安全的主因)方式处理多个请求的。</p>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>由于servlet只会实例化一次，整个生命周期内所有的请求，都由这一个实例来完成，每个请求对应一个线程去处理，很容易造成线程安全性问题。<br>如果service()方法没有访问Servlet的成员变量也没有访问全局的资源比如静态变量、文件、数据库连接等，而是只使用了当前线程自己的资源，比如非指向全局资源的临时变量、request和response对象等。该方法本身就是线程安全的，不必进行任何的同步控制。<br>如果service()方法访问了Servlet的成员变量，但是对该变量的操作是只读操作，该方法本身就是线程安全的，不必进行任何的同步控制。<br>如果service()方法访问了Servlet的成员变量，并且对该变量的操作既有读又有写，通常需要加上同步控制语句。<br>如果service()方法访问了全局的静态变量，如果同一时刻系统中也可能有其它线程访问该静态变量，如果既有读也有写的操作，通常需要加上同步控制语句。<br>如果service()方法访问了全局的资源，比如文件、数据库连接等，通常需要加上同步控制语句。</p>
<h3 id="JSP本质上就是servlet"><a href="#JSP本质上就是servlet" class="headerlink" title="JSP本质上就是servlet"></a>JSP本质上就是servlet</h3><p>Java服务器页面（JSP）是HttpServlet的扩展。由于HttpServlet大多是用来响应HTTP请求，并返回Web页面（例如HTML、XML），所以不可避免地，在编写servlet时会涉及大量的HTML内容，这给servlet的书写效率和可读性带来很大障碍，JSP便是在这个基础上产生的。其功能是使用HTML的书写格式，在适当的地方加入Java代码片段，将程序员从复杂的HTML中解放出来，更专注于servlet本身的内容。JSP在首次被访问的时候被应用服务器转换为servlet，在以后的运行中，容器直接调用这个servlet，而不再访问JSP页面。<br>所以说JSP本质上就是servlet,在执行的时候最终会被编译成servlet。JSP加入了各种Web标签，使其能更加方便的编写动态Web应用程序。JSP 由 HTML 代码和 JSP 标签构成，可以方便地编写动态网页,Servlet完全是JAVA程序代码构成擅长于流程控制和事务处理.因此在实际应用中采用 Servlet 来控制业务流程,而采用 JSP 来生成动态网页.Servlet和JSP两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。</p>
<h2 id="容器和server"><a href="#容器和server" class="headerlink" title="容器和server"></a>容器和server</h2><h3 id="web-server"><a href="#web-server" class="headerlink" title="web server"></a>web server</h3><p>只要Web上的Server都叫Web Server，但是大家分工不同，解决的问题也不同，所以根据Web Server提供的功能，每个Web Server的名字也会不一样。按功能分类，Web Server可以分为：Http server和Application server。</p>
<h3 id="Http-server"><a href="#Http-server" class="headerlink" title="Http server"></a>Http server</h3><p>HTTP Server本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的IP地址并监听某一个tcp端口来接收并处理HTTP请求，这样客户端（一般来说是IE, Firefox，Chrome这样的浏览器）就能够通过HTTP协议来获取服务器上的网页（HTML格式）、文档（PDF格式）、音频（MP4格式）、视频（MOV格式）等等资源。HTTP Server中经常使用的是Apache、Nginx两种，HTTP Server主要用来做静态内容服务、代理服务器、负载均衡等。直面外来请求转发给后面的应用服务（Tomcat，django什么的）。</p>
<h3 id="Application-Server"><a href="#Application-Server" class="headerlink" title="Application Server"></a>Application Server</h3><p>Application Server 是一个应用执行的服务器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。与HTTP Server相比，Application Server能够动态的生成资源并返回到客户端。</p>
<blockquote>
<p>Application server可以作为servlet容器，tomcat、jeety等都是Application server都可以作为servlet容器。对于Tomcat来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以Application Server往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。</p>
<p>在实际运行的时候Java Servlet与Web服务器会融为一体，如同一个程序一样运行在同一个Java虚拟机（JVM）当中。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。另外因为Java Servlet是运行在虚拟机之上的，也就解决了跨平台问题。如果没有Servlet的出现，也就没有互联网的今天。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/xianggao/blog/670681" target="_blank" rel="external">https://my.oschina.net/xianggao/blog/670681</a><br><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="external">http://www.hollischuang.com/archives/849</a><br><a href="http://developer.51cto.com/art/201012/237827.htm" target="_blank" rel="external">http://developer.51cto.com/art/201012/237827.htm</a><br><a href="http://www.10tiao.com/html/308/201609/2650076215/1.html" target="_blank" rel="external">http://www.10tiao.com/html/308/201609/2650076215/1.html</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/22/java/JSP%E5%92%8CServlet/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git多账号配置（Windows平台）</title>
      <link>https://yanglukuan.github.io/2017/08/21/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</link>
      <guid>https://yanglukuan.github.io/2017/08/21/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Mon, 21 Aug 2017 06:10:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;Git的配置相信大家都不陌生了，如果还不熟悉，不要着急，继续往下看就好了。今天主要看一下多账户的场景，顺便也复习一下Git的配置流程。  &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么情况下需要多账户的配置呢？&quot;&gt;&lt;a href=&quot;#什么情况下需要多账户的配置呢？&quot; class=
      
      </description>
      
      <content:encoded><![CDATA[<p>Git的配置相信大家都不陌生了，如果还不熟悉，不要着急，继续往下看就好了。今天主要看一下多账户的场景，顺便也复习一下Git的配置流程。  </p>
<hr>
<h2 id="什么情况下需要多账户的配置呢？"><a href="#什么情况下需要多账户的配置呢？" class="headerlink" title="什么情况下需要多账户的配置呢？"></a>什么情况下需要多账户的配置呢？</h2><p>1.在公司一般大家都会配置公司的代码仓库的账户，用的账号一般是公司企业邮箱账号,比如<code>zhangsan@XXX.com</code>,一般的配置流程都是企业入职的时候给一个配置清单或者新手指导，员工自己按照指导去配置，无非也就是用git的SSH 命令生成密钥对，然后将公钥上传至管理平台，就可以很开心的写Bug了，哦 不对，写码。<br>但是某一天有这样一个场景，有时候自己也会写点代码，这些代码一般我们托管在GitHub等平台上，这个时候就无法使用公司的账号了，需要再配置一个GitHub的账号，比如<code>zhangsan@Gmail.com</code>这样的账户名字。<br>2.由于天朝独特的网络环境,你们懂得，有时候GitHub无法连接或者不稳定，这个时候需要有一个国内的代码托管平台，国内比如码云这样的平台也可以托管代码，速度比较稳定。这个时候就需要同时配置GitHub和码云两个账户。</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><blockquote>
<p>公司账户和GitHub账户（不同邮箱）</p>
</blockquote>
<p>1.如果原来配置过一次，在用户目录下会有一个.ssh目录，里面存放着你默认第一次生成的秘钥对，<code>id_rsa</code>和<code>id_rsa.pub</code>,在此目录打开<code>Git bash</code> 输入命令 <code>ssh-keygen -C &quot;zhangsan@Gmail.com&quot; -t rsa</code> 然后回车 这个时候需要注意，需要给生成的秘钥对命名，比如<code>id_rsa_github</code>，不然会以默认的名字<code>id_rsa</code>生成，从而覆盖掉原来生成的。然后回车两次，就可以成功生成秘钥。<br>2.生成秘钥成功后，把生成公钥上传到GitHub的秘钥管理平台上，然后最重要的步骤来了。<br>回到用户目录的.ssh目录，创建一个config文本文件，注意这个文件名字为config，没有后缀名，尝试过加上.config后缀，貌似不会被识别。这个配置文件就是告诉ssh多个账户下，每个账户对应的秘钥位置和Host位置。<br>config配置文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># github </div><div class="line">Host github.com</div><div class="line">HostName github.com</div><div class="line">User zhangsan</div><div class="line">IdentityFile ~/.ssh/id_rsa_github</div><div class="line"></div><div class="line"># company</div><div class="line">Host code.company.com</div><div class="line">HostName code.company.com</div><div class="line">User zhangsan</div><div class="line">IdentityFile ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<p>这样配置就结束了，打开<code>git bash</code> 输入命令测试一下<br><code>ssh -T git@github.com</code><br>成功的话会收到这样一段回复<br><code>Hi zhangsan! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br>不成功的话，检查下上面的配置，或者使用<code>ssh -vT git@github.com</code>  查看下详细的错误信息。<br>3.有些网友的帖子会说如果配置了全局的Git用户名和邮箱，需要去掉，其实不去掉也是可以的。如果你先设置了公司的账户为全局配置，那么你克隆GitHub上的代码到本地后，只要在那个目录设置本地的用户名和邮箱，就可以了，因为本地的优先级要大于全局的设定，公司的代码目录则继续使用全局配置，一样的互不影响。</p>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><blockquote>
<p>GitHub和码云两个账号</p>
</blockquote>
<p>1.不同邮箱<br>如果你同时拥有GitHub和码云两个账号，而又不是使用同一邮箱注册，其实也类似于上面这张情况，分别生成不同邮箱的秘钥，然后再<code>config</code>文件里配置相应的用户、秘钥位置和<code>Host</code>就可以了。<br>2.相同邮箱<br>如果是相同的邮箱，就不需要上面的配置，只要用这个邮箱生成一次秘钥，这个秘钥可以同时用在两个网站上，两个远程仓库都可以提交，因为<code>SSH</code>秘钥是用邮箱生成的，邮箱相同，则秘钥也相同，所以可以共用一个。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/89cb26e5c3e8" target="_blank" rel="external">http://www.jianshu.com/p/89cb26e5c3e8</a><br><a href="https://gist.github.com/suziewong/4378434" target="_blank" rel="external">https://gist.github.com/suziewong/4378434</a><br><a href="http://noahsnail.com/2016/08/31/2016-9-1-Git%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">http://noahsnail.com/2016/08/31/2016-9-1-Git%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/</a><br><a href="https://steflerjiang.github.io/2016/12/16/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">https://steflerjiang.github.io/2016/12/16/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/21/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SonarQube 服务搭建与配置</title>
      <link>https://yanglukuan.github.io/2017/08/20/sonar%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/</link>
      <guid>https://yanglukuan.github.io/2017/08/20/sonar%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Sun, 20 Aug 2017 07:07:49 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;SonarQube是神马&quot;&gt;&lt;a href=&quot;#SonarQube是神马&quot; class=&quot;headerlink&quot; title=&quot;SonarQube是神马&quot;&gt;&lt;/a&gt;SonarQube是神马&lt;/h2&gt;&lt;p&gt;   1.&lt;code&gt;SonarQube（又叫Sonar）&lt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="SonarQube是神马"><a href="#SonarQube是神马" class="headerlink" title="SonarQube是神马"></a>SonarQube是神马</h2><p>   1.<code>SonarQube（又叫Sonar）</code>是对代码进行静态检测的开源平台,利用这个工具可以发现我们代码里各种隐藏的Bug和潜在的问     题，在团队协作的开发模式中可以更好的控制代码质量。<br>   2.支持多种平台<code>（Windows、Linux）</code>和多种开发语言<code>(java、C#、JavaScript、PHP等)</code>,并可以和<code>Jekins、JIRA</code>等多种外部工具和<code>IntelliJ IDEA</code>等开发工具无缝集成。<br>   3.可视化界面，提供各种维度的质量查询和分析。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h3><ul>
<li>下载软件<br><code>SonarQube</code> <a href="https://www.sonarqube.org/downloads/" target="_blank" rel="external">https://www.sonarqube.org/downloads/</a><br>规则插件 <code>checkstyle</code>  <a href="https://github.com/checkstyle/sonar-checkstyle" target="_blank" rel="external">https://github.com/checkstyle/sonar-checkstyle</a><br><code>pmd</code> <a href="https://github.com/SonarQubeCommunity/sonar-pmd" target="_blank" rel="external">https://github.com/SonarQubeCommunity/sonar-pmd</a><br><code>findbugs</code> <a href="https://github.com/SonarQubeCommunity/sonar-findbugs" target="_blank" rel="external">https://github.com/SonarQubeCommunity/sonar-findbugs</a><br>汉化插件 <code>sonar-l10n-zh-master</code> <a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="external">https://github.com/SonarQubeCommunity/sonar-l10n-zh</a><br>本地扫描插件 <code>sonar-runner-dist-2.4</code> <a href="http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.4/" target="_blank" rel="external">http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.4/</a><br><strong>以上插件均是源码 需要下载后自行编译</strong></li>
<li>所需环境<br><code>JDK1.7</code>或以上<br><code>Maven</code><br><code>Mysql</code></li>
<li><p>配置<br>a.<code>sonarqube\conf</code> 配置<br><code>sonar.properties</code>内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sonar.jdbc.username=sonar</div><div class="line">sonar.jdbc.password=sonar</div><div class="line">sonar.jdbc.url=jdbc:mysql://127.0.0.1:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</div></pre></td></tr></table></figure>
<p>b.mysql 配置</p>
<ul>
<li><p>在mysql管理器中执行如下脚本创建数据库及mysql用户  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> sonar <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;  </div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'sonar'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</div><div class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sonar.* <span class="keyword">TO</span> <span class="string">'sonar'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</div><div class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sonar.* <span class="keyword">TO</span> <span class="string">'sonar'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</div><div class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><code>mysql max_allowed_packet</code>配置<br>路径 <code>C:\ProgramData\MySQL\MySQL Server 5.6\my.ini</code><br>设置 <code>max_allowed_packet=101943040</code></p>
</li>
</ul>
</li>
<li>插件编译 安装<br>分别编译下载的插件,去掉<code>snapshort</code>标记,放入插件目录下<code>sonarqube-6.4\extensions\plugins</code></li>
<li>启动<br>至此,启动mysql,启动<code>sonarqube</code>,本地访问 <code>http://localhost:9000/</code><br>可看到管理界面<br>登录名\密码   <code>admin\admin</code></li>
</ul>
<h3 id="扫描配置"><a href="#扫描配置" class="headerlink" title="扫描配置"></a><strong>扫描配置</strong></h3><ul>
<li><p><code>maven</code>扫描 配置<br><code>maven</code>配置文件添加节点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">activation</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.url</span>&gt;</span></div><div class="line">&lt;![CDATA[jdbc:mysql://127.0.0.1:3306/sonar]]&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">sonar.jdbc.url</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">sonar.jdbc.driver</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.username</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">sonar.jdbc.username</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.password</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">sonar.jdbc.password</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sonar.jdbc.maxWait</span>&gt;</span>50000<span class="tag">&lt;/<span class="name">sonar.jdbc.maxWait</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sonar.jdbc.minEvictableIdleTimeMillis</span>&gt;</span>600000<span class="tag">&lt;/<span class="name">sonar.jdbc.minEvictableIdleTimeMillis</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.timeBetweenEvictionRunsMillis</span>&gt;</span>30000<span class="tag">&lt;/<span class="name">sonar.jdbc.timeBetweenEvictionRunsMillis</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span>http://localhost:9000<span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div></pre></td></tr></table></figure>
<p>执行maven命令<code>mvn sonar:sonar</code> 可扫描项目并上传质量报告</p>
</li>
<li><p><code>sonar-runner</code> 扫描配置<br>a.环境变量配置<br>系统环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SONAR_RUNNER_HOME  D:\Java\sonar-runner-2.4</div><div class="line">Path 追加 ;%SONAR_RUNNER_HOME%\bin;</div></pre></td></tr></table></figure>
<p>b.sonar-runner.properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#Configure here general information about the environment, such as SonarQube DB details for example</div><div class="line">#No information about specific project should appear here</div><div class="line">  </div><div class="line">#----- Default SonarQube server</div><div class="line">sonar.host.url=http://localhost:9000</div><div class="line">  </div><div class="line">#----- PostgreSQL</div><div class="line">#sonar.jdbc.url=jdbc:postgresql://localhost/sonar</div><div class="line">  </div><div class="line">#----- MySQL</div><div class="line">sonar.jdbc.url=jdbc:mysql://127.0.0.1:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8</div><div class="line">  </div><div class="line">#----- Oracle</div><div class="line">#sonar.jdbc.url=jdbc:oracle:thin:@localhost/XE</div><div class="line">  </div><div class="line">#----- Microsoft SQLServer</div><div class="line">#sonar.jdbc.url=jdbc:jtds:sqlserver://localhost/sonar;SelectMethod=Cursor</div><div class="line">  </div><div class="line">#----- Global database settings</div><div class="line">sonar.jdbc.username=sonar</div><div class="line">sonar.jdbc.password=sonar</div><div class="line">  </div><div class="line">#----- Default source code encoding</div><div class="line">sonar.sourceEncoding=UTF-8</div><div class="line">  </div><div class="line">#----- Security (when 'sonar.forceAuthentication' is set to 'true')</div><div class="line">sonar.login=admin</div><div class="line">sonar.password=admin</div></pre></td></tr></table></figure>
<p>c、本地项目配置文件  项目根目录<br>sonar-project.properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sonar.projectKey=projectKey </div><div class="line">sonar.projectName=projectName</div><div class="line">sonar.projectVersion=1.0</div><div class="line"># Set modules IDs</div><div class="line">sonar.modules=projectmodules</div><div class="line"></div><div class="line"># Modules inherit properties set at parent level</div><div class="line">sonar.sources=src</div><div class="line">sonar.sourceEncoding=UTF-8</div><div class="line">sonar.language=java</div><div class="line">sonar.java.binaries=target</div><div class="line"># By default, the base directory for a module is <span class="tag">&lt;<span class="name">current_dir</span>&gt;</span>/<span class="tag">&lt;<span class="name">module_ID</span>&gt;</span>.</div></pre></td></tr></table></figure>
<p>至此  使用命令行进入到项目根目录<br>输入命令 <code>sonar-runner</code> 可以完成项目的扫描和上传报告  </p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/22926742" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22926742</a><br><a href="http://blog.csdn.net/xiajian2010/article/details/22983825" target="_blank" rel="external">http://blog.csdn.net/xiajian2010/article/details/22983825</a><br><a href="http://www.cnblogs.com/parryyang/p/6270402.html" target="_blank" rel="external">http://www.cnblogs.com/parryyang/p/6270402.html</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/20/sonar%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo+GitHub Pages博客搭建</title>
      <link>https://yanglukuan.github.io/2017/08/17/firstblog/</link>
      <guid>https://yanglukuan.github.io/2017/08/17/firstblog/</guid>
      <pubDate>Thu, 17 Aug 2017 06:56:25 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;闲扯一会&quot;&gt;&lt;a href=&quot;#闲扯一会&quot; class=&quot;headerlink&quot; title=&quot;闲扯一会&quot;&gt;&lt;/a&gt;闲扯一会&lt;/h2&gt;&lt;p&gt;生命不息，学习不止。最近读了不少书和博客,但是读下来发现了一些问题。比如，有些知识点看过很多次，每次看的时候都觉得似曾相识，
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="闲扯一会"><a href="#闲扯一会" class="headerlink" title="闲扯一会"></a>闲扯一会</h2><p>生命不息，学习不止。最近读了不少书和博客,但是读下来发现了一些问题。比如，有些知识点看过很多次，每次看的时候都觉得似曾相识，却又记不起全貌。有些则是过目就忘，合上书本完全不记得书中所讲精要，甚是苦闷。这几日忽得夫人点拨，说是输出倒逼输入，意思就是充当别人的老师，然后逼自己学习更多的知识。这个道理大家自然都是懂得，只不过有时候做起来比较难以实践。一个是因为人都有惰性，好多事情都是停留在思想和嘴巴，付诸行动的少之又少。再者，也不太容易有机会充当别人的老师，而且本身我自己也不是那种好为人师的性格，倒不是清高装逼，也是怕误人子弟。<br>不过我们这个行业比较特殊，可以有很好的方式去做输出倒逼输入的事情，比如写博客。其实很早就注册了博客园，但是到现在也只是酱油和灌水，没有发过帖子。现在决定写博客，把自己的输入真正变成自己的东西，一方面在写的过程中梳理一下知识，另一方面也记录下自己解决过的问题、踩过的坑。博客前期打算以Step By Step的教程为主，主要为了熟悉markdown语法和Hexo博客的使用，后面会慢慢转向原理解析类和日常踩坑记录类。<br><strong>往者不可谏,来者犹可追。</strong></p>
<hr>
<h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h3 id="GitHub-Pages-设置"><a href="#GitHub-Pages-设置" class="headerlink" title="GitHub Pages 设置"></a>GitHub Pages 设置</h3><p>   Github Pages 是 Github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制，还可以绑定自己的域名。在 <a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a> 首页上可以看到很多用 Github Pages 托管的网站，很漂亮。另外很多非常著名的公司和项目也都用这种方式来搭建网站，如微软和 twitter 的网站，还有 谷歌的 Material Design 图标 网站。本博客就是利用Github Pages托管所建。开始创建自己的网站：<br>   创建一个新的仓库  <code>yourname.github.io</code>，<code>yourname</code> 就是你github的用户名，不可以是其他字符，不然访问不到。<br>   只要把静态的网站文件上传到这个仓库，然后访问<code>https://yourname.github.io</code>，就可以看到自己的网站了。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>   Hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。<br>   所需环境<br>   Nodejs<br>   Git</p>
<p>1.首先安装好Nodejs和Git,Hexo安装过程中，有些文件是通过Git下载下来。<br>安装cnpm 由于天朝网路环境问题，所以最好安装cnpm 淘宝的镜像，下载比较快<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>全局安装hexo<br><code>cnpm install hexo-cli -g</code><br>新建一个hexo/blog文件夹<br>进入到你的hexo/blog目录<br>打开git bash<br><code>cnpm install hexo --save</code><br>检查是否安装成功<br><code>hexo -v</code><br>初始化Hexo<br><code>hexo init</code><br>这里会创建一些文件<br>然后输入<br><code>cnpm install</code><br>这里要等一会，安装组件</p>
<p>2.然后就可以使用了<br>常用命令<br><code>hexo new &quot;Hello World&quot;</code> 创建新页面<br><code>hexo generate</code> 重新生成所有页面<br><code>hexo server</code> 启动本地预览  预览地址 <code>http://localhost:4000</code><br> 会看到一个默认主题的hexo网站。</p>
<p> <code>hexo new</code> 命令会创建一个md格式的文件，就是我们写博客的文件，推荐使用markdownpad来写，支持各种markdown格式，<br> 其实在使用过程中无需使用此命令创建，只要在blog下的<code>\source\_posts</code>文件夹下直接新建md格式的文件就可以了。Hexo在生成博客的时候回自动识别这个目录下写所有md文件。</p>
<p>3.发布到GitHub<br> 找到blog目录下的<code>_config.yml</code>文件，加入以下节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type: git</div><div class="line">repo:</div><div class="line">  github: &lt;repository url&gt;,[branch]</div></pre></td></tr></table></figure></p>
<p>执行命令<br>hexo d 就可以完成发布，发布成功后，就可以在<code>https://yourname.github.io</code>看到自己更新的内容了，由于CDN缓存的缘故，有时候更新后要过一会才可以看到最新的内容。</p>
<h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><p>   <a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a><br>   <a href="http://gitbeijing.com/pages.html" target="_blank" rel="external">http://gitbeijing.com/pages.html</a><br>   <a href="http://www.jianshu.com/p/b8dd1e3e0255" target="_blank" rel="external">http://www.jianshu.com/p/b8dd1e3e0255</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/17/firstblog/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
