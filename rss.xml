<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kevin.yang</title>
    <link>https://yanglukuan.github.io/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>博闻强记</description>
    <pubDate>Thu, 07 Sep 2017 14:09:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java集合框架之ArrayList详解</title>
      <link>https://yanglukuan.github.io/2017/09/08/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://yanglukuan.github.io/2017/09/08/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Fri, 08 Sep 2017 06:24:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文基于&lt;code&gt;jdk1.8&lt;/code&gt;介绍&lt;code&gt;ArrayList&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;java-集合框架&quot;&gt;&lt;a href=&quot;#java-集合框架&quot; class=&quot;headerlink&quot; title=&quot;java 集合框架&quot;&gt;&lt;/a&gt;jav
      
      </description>
      
      <content:encoded><![CDATA[<p>本文基于<code>jdk1.8</code>介绍<code>ArrayList</code>。</p>
<h2 id="java-集合框架"><a href="#java-集合框架" class="headerlink" title="java 集合框架"></a>java 集合框架</h2><p><code>Java</code>的集合类主要由两个接口派生而出：<code>Collection</code>和<code>Map</code>，在前几篇文章中，我们介绍了<code>map</code>接口的几个常用实现类。在接下来的文章中，我们将介绍另一个接口<code>Collection</code>的常用实现类。这些类包括<code>List</code>接口下的<code>ArrayList</code>和<code>LinkedList</code>，<code>Se</code>t接口下的<code>HashSet</code>和<code>LinkedHashSet</code>。下面给出<code>Collection</code>接口的类图：</p>
<center><img src="/images/arrayList/Collections.png" alt="Collection接口类图"></center><center><strong><em>Collection接口类图</em></strong></center>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><center><img src="/images/arrayList/arrayList.png" alt="ArrayList类图"></center><center><strong><em>ArrayList类图</em></strong></center>

<p>结合<code>Collection</code>接口类图和<code>ArrayList</code>类图我们可以看到，<code>ArrayList</code>直接继承自<code>AbstractList</code>，并实现了<code>List</code>接口。<code>AbstractList</code>是一个继承于<code>AbstractCollection</code>，并且实现<code>List</code>接口的抽象类。它实现了<code>List</code>中大部分的方法，从而方便其它类继承<code>List</code>。下面我们来看一下它的数据结构。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>ArrayList</code>实现了 <code>List</code> 接口，它是基于数组的一个实现，意味着可以插入空值，也可以插入重复的值，并且是非线程安全的。结合源码我们可以看到，在<code>ArrayList</code>内部维护着一个<code>Object</code>类型的数组<code>elementData</code>，这个数组就是存放数据元素的结构，所以<code>ArrayList</code>所使用的数据结构为数组，就像它的名字一样。但是我们知道，数组的长度是固定的，而<code>ArrayList</code>的长度却是可变的，这是因为<code>ArrayList</code>内部是以动态数组的形式来存储数据的，这里的动态数组不是意味着去改变原有内部生成的数组的长度，而是保留原有数组的引用，将其指向新生成的数组对象，这样会造成数组的长度可变的假象。<code>DEFAULT_CAPACITY</code>表示数组默认的元素个数，超过这个个数就会触发扩容机制，扩容会设置新的存储能力为原来的1.5倍。<code>Size</code>表示数组<code>elementData</code>元素的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>由于使用了数组的方式存储数据，<code>ArrayList</code>具有数组所具有的特性，元素顺序性、元素可重复等，通过索引支持随机访问，所以通过随机访问<code>ArrayList</code>中的元素效率非常高。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>ArrayList</code>提供了以下三个构造方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 默认构造函数 ArrayList的默认容量大小是10</span></div><div class="line">ArrayList()</div><div class="line"></div><div class="line"><span class="comment">// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。</span></div><div class="line">ArrayList(<span class="keyword">int</span> capacity)</div><div class="line"></div><div class="line"><span class="comment">// 创建一个包含collection的ArrayList</span></div><div class="line">ArrayList(Collection&lt;? extends E&gt; collection)</div></pre></td></tr></table></figure></p>
<p>由于使用了数组的实现方式，容量不足时需要扩容，在使用时如果能确定容量大小，最好使用带容量大小的构造方法去使用，可以免去动态扩容带来的性能开销。</p>
<h3 id="存取实现"><a href="#存取实现" class="headerlink" title="存取实现"></a>存取实现</h3><p>下面我们结合源码来看一下存取的实现过程。</p>
<h4 id="元素添加-add"><a href="#元素添加-add" class="headerlink" title="元素添加 add"></a>元素添加 add</h4><p>首先看一下添加元素的<code>add</code>方法，<code>add</code>方法只有寥寥几行，它内部调用了一个<code>ensureCapacityInternal</code>方法，然后紧跟着就是执行对数组<code>elementData</code>元素的赋值。通过上面的分析和查看源代码，我们知道了，这个<code>ensureCapacityInternal</code>是用来实现数组扩容的功能，扩容结束，又可以继续嗨了，下面我们重点来看一下这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">//检查数组容量 容量不够时扩容</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;<span class="comment">//元素保存</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ensureCapacityInternal</code>方法及内部方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//检查数组容量  minCapacity为当前数组元素数+1 </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">//先判断数组 是否为空</span></div><div class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<span class="comment">//如果数组为空 minCapacity取较大值</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ensureExplicitCapacity(minCapacity);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       modCount++;<span class="comment">//结构性修改+1</span></div><div class="line"></div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line">       <span class="comment">// 如果数组容量不够 就执行扩容</span></div><div class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">           grow(minCapacity); <span class="comment">//执行扩容</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="comment">// overflow-conscious code</span></div><div class="line"></div><div class="line">       <span class="comment">//这里有三个变量 我们先来看一下</span></div><div class="line">       <span class="comment">//oldCapacity：数组当前的长度 </span></div><div class="line">       <span class="comment">//minCapacity: 存储数据至少需要多长 </span></div><div class="line">       <span class="comment">//newCapacity：数组将来的长度 </span></div><div class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//保存原来的数组长度</span></div><div class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//先将数组大小扩展至原来的1.5倍</span></div><div class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//如果新的容量小于所需容量 将所需容量赋值给新的容量</span></div><div class="line">           newCapacity = minCapacity;</div><div class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)<span class="comment">//如果新的数组长度大于数组的最大长度</span></div><div class="line">           newCapacity = hugeCapacity(minCapacity);<span class="comment">//计算新的容量</span></div><div class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//将数组拷贝到已扩容的新数组中</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果所需长度大于数组的最大长度  重新计算数组长度  最大的数组长度可以为 Integer.MAX_VALUE</span></div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">           Integer.MAX_VALUE :</div><div class="line">           MAX_ARRAY_SIZE;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面三个方法完成了对数组<code>elementData</code>的容量检查和扩容，保证了数组在保存元素时有足够的容量。整个检查和扩容的流程如下</p>
<blockquote>
<p>1、获取数组当前元素数<code>size</code>，将<code>size+1</code>代表数组所需要的长度。<br>2、校验数组是否为空，为空则需要进行扩容，扩容的长度就是<code>DEFAULT_CAPACITY与minCapacity</code>的较大值。如果使用默认的无参构造方法，实例化的<code>ArrayList</code>的数组则为空，如果使用带数组长度的构造方法，实例化的<code>ArrayList</code>的数组长度则为构造的长度。<br>3、执行扩容前的计算，决定扩容的长度。这里利用三个变量完成计算，说明一下。<br><code>oldCapacity</code>：数组当前的长度，<code>minCapacity</code>: 存储数据至少需要的长度 ，<code>newCapacity</code>：数组新的长度<br>首先保存当前数组的长度，然后将数组大小扩展1.5倍赋值给数组新的长度，如果新的长度小于所需容量，将所需容量赋值给新的数组长度，这种情况会在数组为空的时候发生。然后如果新的数组长度大于数组的最大长度<code>MAX_ARRAY_SIZE</code>，就重新计算数组长度，最大的数组长度可以为 <code>Integer.MAX_VALUE</code>。<br>4、扩容长度计算完毕，执行扩容，将数组内容拷贝到新的数组，并将新的数组赋值给<code>elementData</code>，完成扩容。<br>5、扩容完成，执行添加元素操作。</p>
</blockquote>
<p>从这个过程可以看出，如果频繁的对<code>ArrayList</code>进行插入操作而同时又不指定集合的长度的话，就会频繁的引起数组动态扩容，由于扩容是使用的数组的拷贝方法，这种方式不仅牺牲了性能而且也对内存空间造成了浪费，如果数据量比较大的话可能会带来比较严重的性能问题，所以如果我们提前能清楚的知道所处理数据的大小，就可以构造一个固定长度的<code>ArrayList</code>，也就省去了动态扩容的开销。</p>
<h4 id="遍历和查找"><a href="#遍历和查找" class="headerlink" title="遍历和查找"></a>遍历和查找</h4><p>说完了添加，下面再说说查找。数组的优势就在于查找了，数组可以使用索引访问任意的元素，实现高效的查找和遍历。查找就是根据下边找到数组元素，比较简单，这里就不再说了，下面来看一下遍历。对<code>ArrayList</code>遍历有以下几种方法：<br><code>Iterator</code>方式，<code>for</code>循环索引随机访问方式，<code>foreach</code>方式，对于这几种方式来说，使用随机访问的方式遍历是效率最高的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于以上的分析，我们来总结以下<code>ArrayList</code>的特性和注意点。<br>1、<code>ArrayList</code>基于数组的数据结构实现，拥有数组的一般特性，有序性，高效的随机访问能力，元素可重复，可为空。<br>2、由于是动态数组，容量不够时需要扩容，扩容带来性能问题，不适合用于频繁增删的场景，如果可以确定数据量大小，推荐使用固定的容量实例化。<br>3、非线程安全，多线程环境谨慎使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/yang1464657625/article/details/59109133" target="_blank" rel="external">http://blog.csdn.net/yang1464657625/article/details/59109133</a><br><a href="http://www.cnblogs.com/leesf456/p/5308358.html" target="_blank" rel="external">http://www.cnblogs.com/leesf456/p/5308358.html</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/09/08/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java集合框架之TreeMap详解</title>
      <link>https://yanglukuan.github.io/2017/09/06/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BTreeMap%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://yanglukuan.github.io/2017/09/06/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BTreeMap%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Wed, 06 Sep 2017 08:05:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文基于&lt;code&gt;jdk1.8&lt;/code&gt;介绍&lt;code&gt;TreeMap&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;TreeMap&quot;&gt;&lt;a href=&quot;#TreeMap&quot; class=&quot;headerlink&quot; title=&quot;TreeMap&quot;&gt;&lt;/a&gt;TreeMap&lt;/h2
      
      </description>
      
      <content:encoded><![CDATA[<p>本文基于<code>jdk1.8</code>介绍<code>TreeMap</code>。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>在上一篇文章<a href="/2017/09/05/java/Java集合框架之LinkedHashMap详解/" title="Java集合框架之LinkedHashMap详解">Java集合框架之LinkedHashMap详解</a>中， 我们介绍了<code>Java</code>集合框架的一个类<code>LinkedHashMap</code>。今天我们来介绍一下<code>java</code>集合框架中的<code>TreeMap</code>，先回顾一下<code>map</code>接口的类图：</p>
<center><img src="/images/hashmap/javacollections.png" alt="Map接口类图"></center><center><strong><em>Map接口类图</em></strong></center>

<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p>从类图中我们可以看到，<code>TreeMap</code>继承自<code>AbstractMap</code>，并实现了<code>NavigableMap</code>、<code>Cloneable</code>和<code>Serializable</code>接口，<code>AbstractMap</code>完成了大部分<code>map</code>接口所支持的方法，而<code>NavigableMap</code>接口继承自<code>SortedMap</code>接口，<code>SortedMap</code>存储的是有序的键值对，他内部维护了一个<code>Comparator</code>比较器，<code>NavigableMap</code>是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。所以可以总结<code>TreeMap</code>有以下特性：</p>
<blockquote>
<p>1、排序性<br>2、可以被克隆<br>3、可以被序列化</p>
</blockquote>
<p>与<code>LinkedHashMap</code>一样，<code>TreeMap</code>也保证了集合元素的顺序性，下面我们就来看一下它是如何实现顺序性的。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>分析一个数据类型最好的办法就是看它的内部存储结构，通过分析存储的数据结构，我们可以更清楚的看到它的实现原理和方法，从而更好的去使用，因为特定的数据结构只有用在特定的场景下，才会发挥它最大的作用。<br><code>TreeMap</code>内部使用的数据结构为<strong>红黑树（Red-Black tree）</strong>，关于红黑树，这里简单介绍一下，红黑树属于二叉排序树，但是在二叉排序树的基础上，又增加了一些规则，比如定义节点的着色等，这样就不会出现一些极端的情况，比如，整个树出现了偏离，变为了单分支结构的树，这样，整个树的高度就是n，n为全部的节点数。在这样的节点分部情况下，查找一个节点所需的时间复杂度为<code>O(n)</code>，为了避免这样的情况，聪明的人类又发明了另一种树形结构，叫做平衡二叉树，平衡二叉树查找、插入和删除在平均和最坏情况下的时间复杂度都是 <code>O(logn)</code>。红黑树就是平衡二叉树的一种实现方式。红黑树定义了一些规则，保证树的高度维持在<code>logn</code>。</p>
<blockquote>
<p>1、每个结点要么是红的要么是黑的。<br>2、根结点是黑的。<br>3、每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。<br>4、如果一个结点是红的，那么它的两个儿子都是黑的。<br>5、对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</p>
</blockquote>
<center><img src="/images/treemap/Red-black_tree.png" alt="红黑树"></center><center><strong><em>红黑树</em></strong> —-图片来自维基百科</center>

<p>按照上述性质我们可以很容易的构造一棵红黑树，但是当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。这里有三个比较重要的操作，左旋、右旋和着色，着色比较好理解，黑色或者红色，我们重点看一下左旋和右旋。<br><strong>左旋</strong></p>
<center><img src="/images/treemap/LeftRoate.png" alt="左旋"></center><center><strong><em>左旋</em></strong></center>

<p>如上图所示，当需要将<code>pivot</code>节点左旋时，我们假设它的右孩子y不是<code>NIL[T]</code>，<code>pivot</code>可以为任何不是<code>NIL[T]</code>的左子结点。左旋以<code>pivot</code>到y之间的链为“支轴”进行，它使y成为该子树的新根，而y的左孩子b则成为pivot的右孩子。</p>
<p><strong>右旋</strong></p>
<center><img src="/images/treemap/RightRotate.png" alt="右旋"></center><center><strong><em>右旋</em></strong></center>

<p>如上图所示，当需要将<code>pivot</code>节点右旋时，我们假设它的左孩子y不是<code>NIL[T]</code>，pivot可以为任何不是<code>NIL[T]</code>的右子结点。右旋以<code>pivot</code>到y之间的链为“支轴”进行，它使y成为该子树的新根，而y的左孩子b则成为<code>pivot</code>的右孩子。</p>
<p>关于红黑树就说到这里，感兴趣的同学可以看一下July大神的博文<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">教你初步了解红黑树</a>，下面我们结合源码来看一下<code>TreeMap</code>是怎么样利用这一结构实现的。</p>
<h3 id="几个基本属性"><a href="#几个基本属性" class="headerlink" title="几个基本属性"></a>几个基本属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;<span class="comment">//比较器</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root; <span class="comment">//根节点</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The number of entries in the tree</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;<span class="comment">//元素数量</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The number of structural modifications to the tree.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;<span class="comment">//修改记录</span></div></pre></td></tr></table></figure>
<p>通过以上代码我们可以看到，<code>TreeMap</code>内部维护着一个比较器<code>comparator</code>，通过这个比较器，可以实现根据<code>key</code>的排序。<code>root</code>是<code>TreeMap</code>存储元素的根节点，这个根节点的类型为<code>Entry&lt;K,V&gt;</code>，是基于红黑树实现的一个数据结构，下面是部分源码，我们可以看到这个<code>Entry&lt;K,V&gt;</code>直接继承了<code>Map.Entry&lt;K,V&gt;</code>，除了基本的<code>key</code>和<code>vlaue</code>属性，还多了其他属性。<code>left</code>表示红黑树结构的左子树节点的引用，<code>right</code>表示右子树几点的引用，<code>parent</code>表示父节点的引用，还有一个<code>color</code>表示当前节点的颜色，这是一个布尔类型的值，通过设置<code>true</code>或者<code>false</code>来表示黑色或者红色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    K key;<span class="comment">//存储键</span></div><div class="line">    V value;<span class="comment">//存储值</span></div><div class="line">    Entry&lt;K,V&gt; left;<span class="comment">//左子树节点引用</span></div><div class="line">    Entry&lt;K,V&gt; right;<span class="comment">//右子树节点引用</span></div><div class="line">    Entry&lt;K,V&gt; parent;<span class="comment">//父节点引用</span></div><div class="line">    <span class="keyword">boolean</span> color = BLACK;<span class="comment">//颜色</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Make a new cell with given key, value, and parent, and with</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; child links, and BLACK color.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//默认构造方法，comparator为空，代表使用key的自然顺序来维持TreeMap的顺序，这里要求key必须实现Comparable接口</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    comparator = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//根据已有的Map构造TreeMap</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.comparator = comparator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//构造一个指定map的TreeMap，同样比较器comparator为空，使用key的自然顺序排序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    comparator = <span class="keyword">null</span>;</div><div class="line">    putAll(m);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//构造一个指定SortedMap的TreeMap，根据SortedMap的比较器来来维持TreeMap的顺序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    comparator = m.comparator();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TreeMap</code>提供了四个构造方法，默认的无参构造方法实例化一个<code>key</code>的自然序列的顺序，要求<code>key</code>必须实现<code>Comparable</code>接口。同时还提供了一个指定比较器的构造方法，用以使用指定比较器实现排序。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>将一个节点添加到红黑树中，通常需要下面几个步骤：</p>
<blockquote>
<p>1、将红黑树当成普通二叉查找树，将节点插入。<br>2、将新插入的节点设置为红色。<br>3、通过旋转和着色，使它恢复平衡，重新变成一颗符合规则的红黑树。</p>
</blockquote>
<p>下面我们重点看一下添加元素的实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;<span class="comment">//如果root为null 说明是添加第一个元素 直接实例化一个Entry 赋值给root</span></div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;<span class="comment">//如果root不为null，说明已存在元素 </span></div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator; </div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">//如果比较器不为null 则使用比较器</span></div><div class="line">        <span class="comment">//找到元素的插入位置</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t; <span class="comment">//parent赋值</span></div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="comment">//当前key小于节点key 向左子树查找</span></div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//当前key大于节点key 向右子树查找</span></div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span> <span class="comment">//相等的情况下 直接更新节点值</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//如果比较器为null 则使用默认比较器</span></div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//如果key为null  则抛出异常</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">       </div><div class="line">        <span class="comment">//找到元素的插入位置</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);<span class="comment">//定义一个新的节点</span></div><div class="line">    <span class="comment">//根据比较结果决定插入到左子树还是右子树</span></div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    fixAfterInsertion(e);<span class="comment">//保持红黑树性质  插入后进行修正</span></div><div class="line">    size++;<span class="comment">//元素树自增</span></div><div class="line">    modCount++; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fixAfterInsertion</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 新增节点后对红黑树的调整方法 */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将新插入节点的颜色设置为红色</span></div><div class="line">    x. color = RED;</div><div class="line">    <span class="comment">// while循环，保证新插入节点x不是根节点或者新插入节点x的父节点不是红色（这两种情况不需要调整）</span></div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x. parent.color == RED) &#123;</div><div class="line">        <span class="comment">// 如果新插入节点x的父节点是祖父节点的左孩子</span></div><div class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf (parentOf(x)))) &#123;</div><div class="line">            <span class="comment">// 取得新插入节点x的叔叔节点</span></div><div class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf (parentOf(x)));</div><div class="line">            <span class="comment">// 如果新插入x的父节点是红色</span></div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                <span class="comment">// 将x的父节点设置为黑色</span></div><div class="line">                setColor(parentOf (x), BLACK);</div><div class="line">                <span class="comment">// 将x的叔叔节点设置为黑色</span></div><div class="line">                setColor(y, BLACK);</div><div class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></div><div class="line">                setColor(parentOf (parentOf(x)), RED);</div><div class="line">                <span class="comment">// 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步奏继续循环</span></div><div class="line">                x = parentOf(parentOf (x));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的右孩子</span></div><div class="line">                <span class="keyword">if</span> (x == rightOf( parentOf(x))) &#123;</div><div class="line">                    <span class="comment">// 左旋父节点</span></div><div class="line">                    x = parentOf(x);</div><div class="line">                    rotateLeft(x);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的左孩子</span></div><div class="line">                <span class="comment">// 将x的父节点设置为黑色</span></div><div class="line">                setColor(parentOf (x), BLACK);</div><div class="line">                <span class="comment">// 将x的祖父节点设置为红色</span></div><div class="line">                setColor(parentOf (parentOf(x)), RED);</div><div class="line">                <span class="comment">// 右旋x的祖父节点</span></div><div class="line">                rotateRight( parentOf(parentOf (x)));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果新插入节点x的父节点是祖父节点的右孩子，下面的步奏和上面的相似，只不过左旋右旋的区分</span></div><div class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf (parentOf(x)));</div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                setColor(parentOf (x), BLACK);</div><div class="line">                setColor(y, BLACK);</div><div class="line">                setColor(parentOf (parentOf(x)), RED);</div><div class="line">                x = parentOf(parentOf (x));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (x == leftOf( parentOf(x))) &#123;</div><div class="line">                    x = parentOf(x);</div><div class="line">                    rotateRight(x);</div><div class="line">                &#125;</div><div class="line">                setColor(parentOf (x), BLACK);</div><div class="line">                setColor(parentOf (parentOf(x)), RED);</div><div class="line">                rotateLeft( parentOf(parentOf (x)));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 最后将根节点设置为黑色</span></div><div class="line">    root.color = BLACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、基于红黑树（<code>Red-Black tree</code>）的数据结构实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 <code>Comparator</code> 进行排序，具体取决于使用的构造方法。<br>2、不允许插入为<code>Null</code>的<code>key</code><br>3、可以插入值为<code>Null</code>的<code>Value</code><br>4、若<code>Key</code>重复，则后面插入的直接覆盖原来的<code>Value</code><br>5、非线程安全<br>6、根据<code>key</code>排序，<code>key</code>必须实现<code>Comparable</code>接口，可自定义比较器实现排序。<br>7、<code>TreeMap</code>使用的数据结构决定了他的插入操作变的比较复杂，需要维护一个红黑树，所以<code>TreeMap</code>不适合用在频繁修改的场景，如果不需要实现有序性，则建议使用<code>HashMap</code>，存取效率要高一些。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/fc5e16b5c674" target="_blank" rel="external">http://www.jianshu.com/p/fc5e16b5c674</a><br><a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6105630</a><br><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="external">https://zh.wikipedia.org/wiki/AVL%E6%A0%91</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/09/06/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BTreeMap%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java集合框架之LinkedHashMap详解</title>
      <link>https://yanglukuan.github.io/2017/09/05/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://yanglukuan.github.io/2017/09/05/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Tue, 05 Sep 2017 03:27:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文基于&lt;code&gt;jdk1.8&lt;/code&gt;介绍&lt;code&gt;LinkedHashMap&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;LinkedHashMap&quot;&gt;&lt;a href=&quot;#LinkedHashMap&quot; class=&quot;headerlink&quot; title=&quot;Linked
      
      </description>
      
      <content:encoded><![CDATA[<p>本文基于<code>jdk1.8</code>介绍<code>LinkedHashMap</code>。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>在上一篇文章<a href="/2017/08/31/java/HashMap详解/" title="Java集合框架之HashMap详解">Java集合框架之HashMap详解</a>中， 我们介绍了Java集合框架的一个类<code>HashMap</code>。通过源码分析，我们了解了<code>HashMap</code>的存储结构和内部实现，如果还有不清楚的,那就再回顾一下，因为我们今天要介绍的<code>LinkedHashMap</code>是<code>HashMap</code>的子类，很多方法和属性都直接继承于<code>HashMap</code>。</p>
<p><center><img src="/images/hashmap/javacollections.png" alt="Map接口类图"></center><center><strong><em>Map接口类图</em></strong></center></p>
<h2 id="与HashMap异同"><a href="#与HashMap异同" class="headerlink" title="与HashMap异同"></a>与HashMap异同</h2><p>从上面的类图中我们可以看到,<code>LinkedHashMap</code>直接继承自<code>HashMap</code>，所以<code>LinkedHashMap</code>拥有<code>HashMap</code>的大部分特性，最多只允许一个<code>key</code>为<code>null</code>，可以有多个<code>value</code>为<code>null</code>。一些主要的方法和属性也直接继承自<code>HashMap</code>，并对其中某些方法进行了重写。<code>LinkedHashMap</code>与<code>HashMap</code>最大的不同在于<code>LinkedHashMap</code>保持了元素的有序性，即遍历<code>LinkedHashMap</code>的时候，得到的元素的顺序与添加元素的顺序是相同的，可以按照插入序 <code>(insertion-order)</code>或访问序 <code>(access-order)</code>来对哈希表中的元素进行遍历。</p>
<blockquote>
<p>所谓插入顺序，就是 <code>Entry</code>被添加到 <code>Map</code> 中的顺序，更新一个 <code>Key</code> 关联的 <code>Value</code> 并不会对插入顺序造成影响,而访问顺序则是对所有 <code>Entry</code> 按照最近访问<code>(least-recently)</code>到最远访问<code>(most-recently)</code>进行排序，读写都会影响到访问顺序，但是对迭代器 <code>(entrySet(), keySet(), values())</code> 的访问不会影响到访问顺序。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用<code>get</code>方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p>
</blockquote>
<h2 id="顺序存取原理"><a href="#顺序存取原理" class="headerlink" title="顺序存取原理"></a>顺序存取原理</h2><p><code>LinkedHashMap</code>之所以能实现存取的顺序性，主要是他重新定义了 <code>Entry&lt;K,V&gt;</code> ，这个新的 <code>Entry&lt;K,V&gt;</code> 继承自<code>HashMap.Node&lt;K,V&gt;</code>，并做了新的扩展，下面我们结合源码来分析一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="存取结构"><a href="#存取结构" class="headerlink" title="存取结构"></a>存取结构</h3><p>由上面的代码我们可以看出，这个自定义的 <code>Entry&lt;K,V&gt;</code>比 <code>HashMap.Node&lt;K,V&gt;</code>多了两个属性，<code>before</code>和<code>after</code>。正是使用这两个关键的属性，在<code>LinkedHashMap</code>内部实现了一个双向链表。数据结构的知识大家再回忆一下（想不起来的可以去面壁了），双向链表就是每个节点除了存储数据本身之外，还保存着两个指针，在<code>java</code>里面就是指向对象的引用，一个是前驱节点，也就是他的前一个节点的引用，一个是后继节点，也就是他的后一个节点的引用。这样，就可以实现存储一个有序节点的数据结构了。（这里说明下，在jdk1.7中，使用的结构为环形双向链表）另外，继承自<code>HashMap.Node&lt;K,V&gt;</code>的<code>Entry&lt;K,V&gt;</code>自身还保留着用于维持单链表的<code>next</code>属性，因此<code>LinkedHashMap</code>的<code>Entry</code>节点具有三个指针域，<code>next</code>指针维护<code>Hash</code>桶中冲突<code>key</code>的链表，<code>before</code>和<code>after</code>维护双向链表。结构如下图所示：</p>
<p><center><img src="/images/linkedhashmap/LinkedHashMap.png" alt="LinkedHashMap存储结构"></center><center><strong><em>LinkedHashMap存储结构</em></strong></center><br>以上就是<code>LinkedHashMap</code>的数据结构，但是光有数据机构显然无法完成有序的存取，下面我们继续来看一下，<code>LinkedHashMap</code>的存取过程。</p>
<h3 id="存取过程"><a href="#存取过程" class="headerlink" title="存取过程"></a>存取过程</h3><p>上面提到<code>LinkedHashMap</code>继承自<code>HashMap</code>，所以，<code>LinkedHashMap</code>的自身便拥有了<code>HashMap</code>全部的属性和方法。由代码我们也能看出，<code>LinkedHashMap</code>自身并没有实现<code>put</code>方法，而是直接使用其父类<code>HashMap</code>的<code>put</code>方法。不同的是，在创建<code>Entry</code>时，重写了父类的<code>newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {}</code>方法，并实现了父类预留的回调方法，通过重写父类的方法和回调方法，<code>LinkedHashMap</code>扩展了<code>HashMap</code>，使其拥有了保持存取顺序性的能力。从这点我们也可以看出，<code>java</code>的开发团队将这一功能实现的比较优雅，其中的思想值得我们在开发中借鉴和学习，这也是我们阅读<code>java</code>源码的意义所在。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建新的节点</span></div><div class="line"> <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">     LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">         <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">     linkNodeLast(p);</div><div class="line">     <span class="keyword">return</span> p;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">// link at the end of list</span></div><div class="line"> <span class="comment">//将节点添加到双向链表尾部</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">     LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">     tail = p;</div><div class="line">     <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">         head = p;</div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">         p.before = last;</div><div class="line">         last.after = p;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><code>LinkedHashMap</code>的<code>put</code>过程和<code>HashMap</code>大致相同，包括计算<code>hash</code>值、计算<code>table</code>数组索引、判断数组是否为空等步骤，不同的是创建节点的过程。从上面的代码中我们可以看出，重写的这个<code>newNode</code>方法代码比较简洁，首先实例化一个双链表结构的<code>Entry&lt;K,V&gt; p</code>，这里会首先调用其父类 <code>HashMap.Node</code>的构造方法，维护着一个单链表的结构。实例化结束后，会调用一个<code>linkNodeLast</code>的私有方法，这个方法完成了将新的元素添加至双向链表的尾部的功能。我们知道，在<code>HashMap</code>中，如果单链表超过一定的长度，就会被转换为红黑树，那么在<code>LinkedHashMap</code>中也是同样的逻辑，于是就有了下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建新的红黑树节点</span></div><div class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</div><div class="line">     TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</div><div class="line">     linkNodeLast(p);</div><div class="line">     <span class="keyword">return</span> p;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//将链表节点转换为红黑树节点</span></div><div class="line"> <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</div><div class="line">     LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</div><div class="line">     TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</div><div class="line">     transferLinks(q, t);<span class="comment">//将双向链表中的TreeNode替换为新的普通节点</span></div><div class="line">     <span class="keyword">return</span> t;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这两个也是被重写的方法，当存储结构为红黑树的时候，调用<code>newTreeNode</code>方法创建红黑树节点。当需要将链表转换为红黑树结构时，调用<code>replacementTreeNode</code>方法将双向链表中的<code>TreeNode</code>替换为新的链表节点。<br>由以上分析过程可以得出结论，在 <code>LinkedHashMap</code> 中，所有的 <code>Entry</code> 都被串联在一个双向链表中。每次在新建一个节点时都会将新建的节点链接到双向链表的末尾。这样从双向链表的尾部向头部遍历就可以保证插入顺序了，头部节点是最早添加的节点，而尾部节点则是最近添加的节点。上面我们还提到，<code>LinkedHashMap</code>可以实现插入的顺序和访问的顺序，那么访问的顺序是怎样实现的呢？下面我们来看一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">    putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们通过观察<code>LinkedHashMap</code>的构造函数可以发现有这样一个字段，<code>accessOrder</code>，他的初始值为<code>false</code>。这个字段的意思是是否使用访问序,所以<code>LinkedHashMap</code>的默认顺序为插入顺序。上文我们提到了在<code>HashMap</code>类中预留了几个回调方法，这几个方法在<code>HashMap</code>中并没有实现，而在<code>LinkedHashMap</code>中这几个方法都有了具体的实现,这些方法就是为了实现访问序，下面我们结合代码来看一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> <span class="comment">//移除节点的回调方法</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></div><div class="line">     <span class="comment">//移除一个节点，双向链表中的连接关系需要调整</span></div><div class="line">     LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">         (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">     p.before = p.after = <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">         head = a;</div><div class="line">     <span class="keyword">else</span></div><div class="line">         b.after = a;</div><div class="line">     <span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">         tail = b;</div><div class="line">     <span class="keyword">else</span></div><div class="line">         a.before = b;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">//插入节点的回调方法</span></div><div class="line"><span class="comment">//构造方法中调用 putMapEntries调用时  evict为false </span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">     LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="comment">//first是头元素，也是最老的元素</span></div><div class="line">    <span class="comment">//在插入序中，就是最先插入的元素</span></div><div class="line">    <span class="comment">//在访问序中，就是最远被访问的元素</span></div><div class="line">    <span class="comment">//这里removeEldestEntry(first)始终返回true，即不删除最老的元素</span></div><div class="line">    <span class="comment">//如果是一个容量固定的cache，可调整removeEldestEntry(first)的实现</span></div><div class="line">     <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">         K key = first.key;</div><div class="line">         removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//访问元素之后的回调方法</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">     LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="comment">//如果是访问序，且当前节点并不是尾节点</span></div><div class="line">    <span class="comment">//将该节点置为双向链表的尾部</span></div><div class="line">     <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">         LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">             (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">         p.after = <span class="keyword">null</span>;</div><div class="line">         <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">             head = a;</div><div class="line">         <span class="keyword">else</span></div><div class="line">             b.after = a;</div><div class="line">         <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">             a.before = b;</div><div class="line">         <span class="keyword">else</span></div><div class="line">             last = b;</div><div class="line">         <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">             head = p;</div><div class="line">         <span class="keyword">else</span> &#123;</div><div class="line">             p.before = last;</div><div class="line">             last.after = p;</div><div class="line">         &#125;</div><div class="line">         tail = p;</div><div class="line">         ++modCount;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>在插入节点、删除节点和访问节点后会调用相应的回调函数。可以看到，在 <code>afterNodeAccess</code> 方法中，如果该<code>LinkedHashMap</code>是访问序，且当前访问的节点不是尾部节点，则该节点会被置为双链表的尾节点。即，在访问序下，最近访问的节点会是尾节点，头节点则是最远访问的节点。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="comment">//所有的节点都被串联在双向链表中，迭代器在迭代时可以利用双向链表的链接关系进行</span></div><div class="line"><span class="comment">//双向链表的顺序是按照插入序或访问序排列的</span></div><div class="line"><span class="comment">// Iterators</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</div><div class="line">    <span class="keyword">int</span> expectedModCount;</div><div class="line"></div><div class="line">    LinkedHashIterator() &#123;</div><div class="line">        next = head;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        current = e;</div><div class="line">        next = e.after;<span class="comment">//直接访问after引用</span></div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; p = current;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        K key = p.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在遍历所有节点时是通过节点的 <code>after</code> 引用进行的。这样，可以从双链表的头部遍历到到双链表的尾部。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于<code>LinkedHashMap</code>，我们就介绍到这里，当然，在这里只列出了部门比较重要的方法，还有很多的方法我们没有分析。如果有兴趣，大家可以对照着jdk1.7和jdk1.8的源码进行分析，会发现两者的实现方式还是有很大区别的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.jrwang.me/2016/java-collections-linkedhashmap/" target="_blank" rel="external">http://blog.jrwang.me/2016/java-collections-linkedhashmap/</a><br><a href="http://www.cnblogs.com/chenpi/p/5294077.html" target="_blank" rel="external">http://www.cnblogs.com/chenpi/p/5294077.html</a><br><a href="http://blog.csdn.net/qq_24692041/article/details/64904806" target="_blank" rel="external">http://blog.csdn.net/qq_24692041/article/details/64904806</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/09/05/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java集合框架之HashMap详解</title>
      <link>https://yanglukuan.github.io/2017/08/31/java/HashMap%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://yanglukuan.github.io/2017/08/31/java/HashMap%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Thu, 31 Aug 2017 05:21:13 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;基础扫盲&quot;&gt;&lt;a href=&quot;#基础扫盲&quot; class=&quot;headerlink&quot; title=&quot;基础扫盲&quot;&gt;&lt;/a&gt;基础扫盲&lt;/h2&gt;&lt;p&gt;本文基于jdk1.8介绍HashMap。&lt;/p&gt;
&lt;h3 id=&quot;java-集合框架&quot;&gt;&lt;a href=&quot;#java-集合框
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="基础扫盲"><a href="#基础扫盲" class="headerlink" title="基础扫盲"></a>基础扫盲</h2><p>本文基于jdk1.8介绍HashMap。</p>
<h3 id="java-集合框架"><a href="#java-集合框架" class="headerlink" title="java 集合框架"></a>java 集合框架</h3><hr>
<p><code>Java</code>的集合类主要由两个接口派生而出：<code>Collection</code>和<code>Map</code>，<code>Collection</code>和<code>Map</code>是<code>Java</code>集合框架的根接口，这两个接口又包含了一些接口或实现类。<code>Set</code>和<code>List</code>接口是<code>Collection</code>接口派生的两个子接口，<code>Queue</code>是<code>Java</code>提供的队列实现，类似于<code>List</code>。<code>Map</code>是一个映射接口，其中的每个元素都是一个<code>key-value</code>键值对，抽象类<code>AbstractMap</code>通过适配器模式实现了<code>Map</code>接口中的大部分函数，<code>TreeMap</code>、<code>HashMap</code>、<code>WeakHashMap</code>等实现类都通过继承<code>AbstractMap</code>来实现，另外，不常用的<code>HashTable</code>直接实现了Map接口。对于<code>Set</code>、<code>List</code>和<code>Map</code>三种集合，最常用的实现类分别是<code>HashSet</code>、<code>ArrayList</code>和<code>HashMap</code>三个实现类。</p>
<center><img src="/images/hashmap/javacollections.png" alt="Map接口类图"></center><center><strong><em>Map接口类图</em></strong></center>

<p>(1) HashMap：它根据键的<code>hashCode</code>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 <code>HashMap</code>最多只允许一条记录的键为<code>null</code>，允许多条记录的值为<code>null</code>。<code>HashMap</code>非线程安全，即任一时刻可以有多个线程同时写<code>HashMap</code>，可能会导致数据的不一致。如果需要满足线程安全，可以用 <code>Collections</code>的<code>synchronizedMap</code>方法使<code>HashMap</code>具有线程安全的能力，或者使用<code>ConcurrentHashMap</code>。<br>(2) Hashtable：<code>Hashtable</code>是遗留类，很多映射的常用功能与<code>HashMap</code>类似，不同的是它承自<code>Dictionary</code>类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如<code>ConcurrentHashMap</code>，因为<code>ConcurrentHashMap</code>引入了分段锁。<code>Hashtable</code>不建议在新代码中使用，不需要线程安全的场合可以用<code>HashMap</code>替换，需要线程安全的场合可以用<code>ConcurrentHashMap</code>替换。<br>(3) LinkedHashMap：<code>LinkedHashMap是HashMap</code>的一个子类，保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。<br>(4) TreeMap：<code>TreeMap</code>实现<code>SortedMap</code>接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code>遍历<code>TreeMap</code>时，得到的记录是排过序的。如果使用排序的映射，建议使用<code>TreeMap</code>。在使用<code>TreeMap</code>时，<code>key</code>必须实现<code>Comparable</code>接口或者在构造<code>TreeMap</code>传入自定义的<code>Comparator</code>，否则会在运行时抛出<code>java.lang.ClassCastException</code>类型的异常。</p>
<p>对于上述四种<code>Map</code>类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，<code>Map</code>对象很可能就定位不到映射的位置了。</p>
<h3 id="Hash-知识"><a href="#Hash-知识" class="headerlink" title="Hash 知识"></a>Hash 知识</h3><hr>
<p>维基百科的定义</p>
<blockquote>
<p>散列（英语：<code>Hashing</code>）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列。旧译哈希（误以为是人名而采用了音译）。它也常用作一种资讯安全的实作方法，由一串资料中经过散列算法（<code>Hashing algorithms</code>）计算出来的资料指纹（<code>data fingerprint</code>），经常用来识别档案与资料是否有被窜改，以保证档案与资料确实是由原创者所提供。</p>
</blockquote>
<h3 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h3><hr>
<blockquote>
<p>散列函数（或散列算法，又称哈希函数，英语：<code>Hash Function</code>）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（<code>hash values</code>，<code>hash codes</code>，<code>hash sums</code>，或<code>hashes</code>）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p>
</blockquote>
<p>上面是维基百科给出的定义，通俗点来讲，一般情况下，需要在关键字与它在表中的存储位置之间建立一个函数关系，以<code>f(key)</code>作为关键字为<code>key</code>的记录在表中的位置，通常称这个函数<code>f(key)</code>为哈希函数。</p>
<h3 id="哈希表和查找"><a href="#哈希表和查找" class="headerlink" title="哈希表和查找"></a>哈希表和查找</h3><hr>
<p>哈希表是哈希函数的一个主要应用，使用哈希表能够快速的按照关键字查找数据记录。（注意：关键字不是像在加密中所使用的那样是秘密的，但它们都是用来“解锁”或者访问数据的。）例如，在英语字典中的关键字是英文单词，和它们相关的记录包含这些单词的定义。在这种情况下，哈希函数必须把按照字母顺序排列的字符串映射到为哈希表的内部数组所创建的索引上。哈希表是一个在时间和空间上做出权衡的经典例子,在没有碰撞的情况下，检索时间复杂度为O(1)。</p>
<h3 id="Hash-冲突"><a href="#Hash-冲突" class="headerlink" title="Hash 冲突"></a>Hash 冲突</h3><hr>
<p>对不同的关键字可能得到同一散列地址，即 <code>k1!=k2</code>，而<code>f(k1)==f(k2)</code>，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。解决碰撞有很多方法可以使用，最常用的包括链地址法和开地址法。<code>HashMap</code>就是用的链地址的方法解决冲突。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><hr>
<p><code>HashMap</code>是我们经常使用一个映射容器，通过牺牲存储空间来换取检索时间，<code>HashMap</code>是采用了hash表数据结构思想来实现。在<code>key</code>未发生冲突的情况下，搜索时间复杂度为O(1),可以快速定位元素。因此在日常开发中也被程序员广泛使用，例如作为关系映射容器、简单缓存、提高检索速度等。<code>HashMap</code>最多只允许一个键值为<code>null</code>(保存在数据列表中的第0个元素的链表上)，允许<code>value</code>为<code>null</code>值。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><hr>
<p><code>HashMap</code>实现了<code>Map</code>接口，继承<code>AbstractMap</code>。其中<code>Map</code>接口定义了键映射到值的规则，而<code>AbstractMap</code>类提供 <code>Map</code> 接口的骨干实现。<code>java</code>的<code>HashMap</code>结构上采用了数组链表方式，即数组+链表的数据结构，采用这种结构的原因是采用了链地址的方法解决哈希冲突。但是这样带来了一个问题，当某个链表达到一定的长度时，对于链表元素的查找会变成线性搜索，比较耗时。所以在<code>JDK1.8</code>的实现中做了优化，当链表的长度达到一定数量（<code>TREEIFY_THRESHOLD</code>默认值为8）时，会把链表转为红黑树，所以在<code>JDK1.8</code>的版本<code>HashMap</code>的数据结构为数组+链表+红黑树。<br>在<code>HashMap</code>中，通过<code>Node[] table</code>，(<code>jdk 1.7</code>叫做<code>Entry</code>，<code>jdk 1.8</code>加入红黑树后改为<code>Node</code>,原因是和红黑树的实现<code>TreeNode</code>相关联)来实现该结构，该数组可以看做是一个哈希桶数组，每个桶中存放着一个链表，Node是链表节点,并实现了<code>Map.Entry</code>。<code>Node</code>节点存放一个键值对，同时存放一个指向下一个节点的引用。<code>Node</code>是键值对存储单元，通过<code>hash</code>值来确定该元素在数组链表中的位置。基于这个存储结构，我们也可以看出，<code>HashMap</code>是不保证存取的顺序性的，也就是说遍历<code>HashMap</code>的时候，得到的元素的顺序与添加元素的顺序是不同的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  Node结构源码</div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//用来定位数组索引位置，hash值不允许修改。</span></div><div class="line">        <span class="keyword">final</span> K key; <span class="comment">//key, 都是常数不允许修改。同时key是一个不可变对象。</span></div><div class="line">        V value;<span class="comment">//对应value</span></div><div class="line">        Node&lt;K,V&gt; next;<span class="comment">//下一个节点</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">this</span>.hash = hash;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line">        后面代码省略。。。。。。。。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<center><img src="/images/hashmap/hashmapstructure.png" alt="存储结构"></center><center><strong><em>存储结构</em></strong></center>

<h3 id="存取原理"><a href="#存取原理" class="headerlink" title="存取原理"></a>存取原理</h3><hr>
<p><strong>1.构造函数</strong><br>HashMap提供了四个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HashMap();<span class="comment">//构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</span></div><div class="line">HashMap(<span class="keyword">int</span> initialCapacity);<span class="comment">//构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</span></div><div class="line">HashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor);<span class="comment">//构造一个带指定初始容量和加载因子的空 HashMap。</span></div><div class="line">HashMap(Map&lt;? extendsK,? extendsV&gt; m); <span class="comment">//构造一个映射关系与指定 Map 相同的 HashMap。</span></div></pre></td></tr></table></figure></p>
<p>在这里出现了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中初始容量表示哈希表中桶的数量，也就是上一节提到的Node数组table[]的初始长度，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链地址法的散列表来说，查找一个元素的平均时间是<code>O(1+a)</code>，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。<br><strong>2.几个重要的属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. <span class="keyword">int</span> threshold; <span class="comment">// 所能容纳的key-value对极限</span></div><div class="line"><span class="number">2</span>. <span class="keyword">int</span> modCount; <span class="comment">// 修改次数</span></div><div class="line"><span class="number">3</span>. <span class="keyword">int</span> size; <span class="comment">// 元素数量</span></div><div class="line"><span class="number">4</span>. <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 负载因子</span></div></pre></td></tr></table></figure></p>
<p> <strong>threshold</strong><br><code>threshold</code>是<code>HashMap</code>所能容纳的最大数据量的<code>Node</code>(键值对)个数。<code>threshold = length * Load factor</code>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。如果容器中的元素数量超过这个值，那么<code>HashMap</code>就会进行扩容，重新调整元素位置。扩容后的容量是之前容量的2倍。在HashMap中容器的长度必须是2的倍数，这种设计主要是为了在取模和扩容时做优化，同时为了减少冲突，<code>HashMap</code>定位哈希桶索引位置时，也加入了高位参与运算的过程。<br> <strong>size</strong><br>这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度<code>length</code>、容纳最大键值对数量<code>threshold</code>的区别。<br> <strong>modCount</strong><br>字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。<br> <strong>TREEIFY_THRESHOLD</strong><br><code>static final int TREEIFY_THRESHOLD = 8;</code><br>在J<code>DK1.8</code>版本中，对数据结构做了进一步的优化，引入了红黑树。这是一个常数，表示链表长度的一个阈值。如果链表长度大于这个值(默认为8)时，就转为红黑树。利用红黑树提高增删改查的性能，避免之前因为某个链上积累太多元素而影响HashMap性能，使用红黑树使得增删改查等操作复杂度变为<code>O(logN)</code>。<br><strong>3.存取过程</strong><br><code>put</code>是<code>HashMap</code>的核心方法之一，用于存入数据，下面来分析下put方法的执行流程。</p>
<p><center><img src="/images/hashmap/hashmapput.png" alt="put方法执行顺序"></center><center><strong><em>put方法执行顺序</em></strong></center><br>根据分析，<code>put</code>方法的执行步骤如下：<br>1.首先判断<code>table</code>是否为null或者<code>length==0</code>,如果是则先做扩容<br>2.计算索引<br>根据键值<code>key</code>计算<code>hash</code>值在数组链表中的索引位置i。如果<code>key</code>为<code>null</code>,则默认保存到0位置的哈希桶，保证了一个<code>hashMap</code>中只有一个值为<code>null</code>的<code>key</code>。判断<code>table[i]</code>是否为空，如果为空则直接插入，执行。否则执行3。<br>3.判断<code>table[i]</code>的首个元素是否和key一样（通过<code>hashCode</code>以及<code>equals</code>判断），如果相同直接覆盖<code>value</code>，否则转向4。<br>4.判断<code>table[i]</code> 是否为treeNode(是否是红黑树)，如果是红黑树，则直接在树中插入键值对，否则转向5。<br>5.遍历<code>table[i]</code>，判断链表中是否存在相同的key,如果存在则直接覆盖。否则在链表尾部插入新节点（<code>JDK1.7</code>是在头部插入）。插入完成后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，遍历过程中若发现key已经存在直接覆盖value即可。<br>6.插入成功后，判断实际存在的键值对数量<code>size</code>是否超多了最大容量<code>threshold</code>，如果超过，进行扩容。</p>
<p>具体来看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//1.判断是否table为空</span></div><div class="line">        n = (tab = resize()).length;<span class="comment">//扩容</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//2.根据hash值计算索引，(n - 1) &amp; hash。判断该位置是否为空</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//为空 插入新节点</span></div><div class="line">    <span class="keyword">else</span> &#123;<span class="comment">//该位置不为空</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">//3.判断该节点key是否存在 存在直接覆盖value</span></div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p; <span class="comment">//存在直接覆盖value</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//4.判断是否为红黑树</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);<span class="comment">//红黑树 直接插入</span></div><div class="line">        <span class="keyword">else</span> &#123; <span class="comment">//5.链表操作</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//判断链表该节点是否有子节点</span></div><div class="line">                    <span class="comment">//插入新节点（尾部插入）</span></div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//判断是否存在相同的key 如果存在直接覆盖</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;  <span class="comment">//6.如果超过最大容量  扩容</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.HashCode的计算和元素定位</strong><br><code>HashMap</code>的数据结构决定了在整个使用过程包括增加、删除和查找元素时，定位到哈希桶数组的位置都是很关键的第一步。<code>hashMap</code>采用数组链表结构，我们希望插入的元素在表中尽可能的均匀分布，这样能够提高操作效率。而元素的分布情况与<code>hashCode</code>计算算法有关，直接影响<code>hash</code>离散性能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 计算hash值</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 </span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">    可以看作两步：</span></div><div class="line"><span class="comment">    1.   h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line"><span class="comment">    2.   h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line"><span class="comment">     **/</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 锁定数组下标位置(锁定hash桶)</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，直接在代码中用(n - 1) &amp; hash替代，实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定位哈希桶数组分为两个大步骤： </p>
<ol>
<li>计算<code>hash</code>值(取<code>key</code>的<code>hashCode</code>值、高位运算) </li>
<li>根据<code>hash</code>值定位哈希数组位置<br>在数据结构学习中，计算哈希桶数组位置的常用方式就是取模运算，即<code>index = hash% length</code>。通过这种方式可以使得每个元素能够相对均匀的分布在哈希桶数组中，<code>java</code>中的<code>hash</code>也采用了类似的方式。为了提高计算性能，<code>java</code>采用了&amp;计算代替取模。前面我们提到哈希桶数组的长度是2倍数，这个设置是为了对<code>hashMap</code>中的操作进行优化。<br>比如4的二进制是100， 对<code>4</code>取模操作<code>5%4 = 1</code>相当于 <code>101 &amp; 011 = 001 等于1</code>。在《剑指offer》中“二进制中的1的个数”也巧妙运用了<code>n&amp;(n-1)</code>计算整数中出现1的个数。<br>一个<code>hashCode</code>是32位，而如果哈希桶数组长度比较小时，直接对hashCode进行取模运算只考虑了hashCode的低位字节。Java中同时考虑了高位和低位在计算索引位置的作用，保证高地位Bit都能参与到Hash的计算中。在<code>JDK1.8</code>的实现中，优化了高位运算的算法，通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，也保证数组<code>table</code>的<code>length</code>比较小的时候，高低<code>Bit</code>都能参与进来，使得元素更加均匀分散。<br><center><img src="/images/hashmap/hashmaphash.png" alt="Hash计算方式"></center><center><strong><em>Hash计算方式</em></strong></center><br><strong>5.插入元素</strong><br>当元素定位的哈希桶是一个链表时，则采用尾插入法。首先从头遍历链表，根据<code>equals</code>和<code>hashCode</code>来比较<code>key</code>是否相同。因此作为<code>hashMap</code>的<code>key</code>必须同时重载<code>equals</code>方法和<code>hashCode</code>方法。<br><code>JDK 1.7</code>的链表操作采用了头插入法，即新的元素插入到链表头部。在<code>JDK1.8</code>中采用了尾插入法。插入以后如果链表长度大于8，那么就会将链表转换为红黑树。因为如果链表长度过长会导致元素的增删改查效率低下，呈现线性搜索时间。<code>JDK1.8</code>采用采用红黑树进行优化，进而提高<code>HashMap</code>性能。如果哈希桶是一个红黑树，则直接使用红黑树插入方式直接插入到红黑树中。<br><strong>6.扩容</strong><br><code>JDK1.8</code>是在插入元素后判断是否进行扩容，而且扩容条件相对于<code>JDK1.7</code>有所变化。<code>JDK1.7</code>是在插入元素前判断是否需要扩容，不仅要求<code>size</code>大于等于<code>threshold</code>，同时需要<code>table[bucketIndex]</code>不为空时才进行扩容。扩容时新的容器容量是原来的两倍。<code>JDK1.8</code>对于扩容过程进行了优化，提高扩容性能。<br><code>JDK 1.7</code>是通过创建一个容量为原来两倍的新容器，然后遍历原来容器的所有元素并对每个元素重新计算一次在新容器的索引位置，然后插入到新容器中。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/qq_27093465/article/details/52209789" target="_blank" rel="external">http://blog.csdn.net/qq_27093465/article/details/52209789</a><br><a href="http://blog.csdn.net/qq_27093465/article/details/52207152" target="_blank" rel="external">http://blog.csdn.net/qq_27093465/article/details/52207152</a><br><a href="http://www.importnew.com/16599.html" target="_blank" rel="external">http://www.importnew.com/16599.html</a><br><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">https://tech.meituan.com/java-hashmap.html</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/31/java/HashMap%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SOA简述</title>
      <link>https://yanglukuan.github.io/2017/08/24/%E6%9E%B6%E6%9E%84/SOA%E7%AE%80%E8%BF%B0/</link>
      <guid>https://yanglukuan.github.io/2017/08/24/%E6%9E%B6%E6%9E%84/SOA%E7%AE%80%E8%BF%B0/</guid>
      <pubDate>Thu, 24 Aug 2017 03:25:07 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;混沌&quot;&gt;&lt;a href=&quot;#混沌&quot; class=&quot;headerlink&quot; title=&quot;混沌&quot;&gt;&lt;/a&gt;混沌&lt;/h2&gt;&lt;p&gt;接触&lt;code&gt;SOA&lt;/code&gt;也有几年时间了，从未对其概念和模式深究。我们总是对自己每天接触的东西习以为常，甚至视而不见。随着互联网的
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="混沌"><a href="#混沌" class="headerlink" title="混沌"></a>混沌</h2><p>接触<code>SOA</code>也有几年时间了，从未对其概念和模式深究。我们总是对自己每天接触的东西习以为常，甚至视而不见。随着互联网的发展，<code>SOA</code>的架构也随之大行其道，随之而来的是各种高大上的架构模型和技术名称，林林总总让人眼花缭乱。一直以来对这些都是模糊的概念，想去深究也屡不出个头绪。最近看了几篇业界大牛的文章，略有感悟，试着整理下思路，理清一些基本的概念和术语。本文侧重以自己的理解描述<code>SOA</code>是什么以及由<code>SOA</code>衍生而来的各种技术名词和他们之间的关系，不会详细阐述<code>SOA</code>的原理和<code>SOA</code>架构的各种实践。</p>
<h2 id="开悟"><a href="#开悟" class="headerlink" title="开悟"></a>开悟</h2><h3 id="SOA定义"><a href="#SOA定义" class="headerlink" title="SOA定义"></a>SOA定义</h3><ul>
<li><p>先来一段维基百科对<code>SOA</code>的描述</p>
<blockquote>
<p>面向服务的体系结构（英语：<code>service-oriented architecture</code>）是构造分布式计算的应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。它采用开放标准、与软件资源进行交互并采用表示的标准方式。</p>
</blockquote>
<p>怎么样，多么标准的教科书般的定义。不过这个定义未免太过抽象，我们试着从实质的内容来阐述一下，<code>SOA</code>的出现是为了解决一种什么样的问题或者他规定了什么内容。</p>
</li>
<li><p>感性的<code>SOA</code>定义<br><code>SOA</code>不是一种技术，也不是一个标准，而是一种架构方式，包含了服务提供者、服务调用者、服务管理中心等角色，整个架构模式也是围绕着这些角色如何更有效的互相配合，从而实现<code>SOA</code>架构的商业价值。<code>SOA</code>的应用已经非常普及，毕竟从诞生到现在已经二十余年了。1996年由<code>Gartner</code>公司提出，后经过<code>IBM</code>、<code>SUN</code>、<code>BEA</code>、<code>Oracle</code>等公司完善和推广，<code>SOA</code>的思想和理论逐步得到完善。不管是从概念模型上还是具体应用技术上，都已经得到了全面的发展，也衍生出了很多的新的概念和技术,比如<code>HTTP API</code>,云服务，敏捷开发，持续交付，<code>DevOps</code>等，这些技术的发展和成熟也推动着SOA架构的不断演变。</p>
<h3 id="SOA理念"><a href="#SOA理念" class="headerlink" title="SOA理念"></a>SOA理念</h3><p><code>SOA</code>要求开发者从服务集成的角度来设计应用软件，目标为了提高重用性,即使这么做的利益不会马上显现。<code>SOA</code>要求开发者超越应用软件来思考，并考虑复用现有的服务，或者检查如何让服务被重复利用。<code>SOA</code>鼓励使用可替代的技术和方法（例如消息机制），通过把服务联系在一起而非编写新代码来构架应用。</p>
<h3 id="SOA原则"><a href="#SOA原则" class="headerlink" title="SOA原则"></a>SOA原则</h3><p>服务松耦合(<code>Loosely coupled</code>) - 服务之间的关系最小化，只是互相知道。<br>服务契约 - 服务按照服务描述文档所定义的服务契约行事。<br>服务抽象 - 除了服务契约中所描述的内容，服务将对外部隐藏逻辑。<br>服务的重用性 - 将逻辑分布在不同的服务中，以提高服务的重用性。<br>服务的可组合性 - 一组服务可以协调工作并组合起来形成一个组合服务。<br>服务自治 – 服务对所封装的逻辑具有控制权<br>服务无状态 – 服务将一个活动所需保存的资讯最小化。<br>服务的可被发现性 – 服务需要对外部提供描述资讯，这样可以通过现有的发现机制发现并访问这些服务。</p>
</li>
</ul>
<blockquote>
<p>这样，我们对<code>SOA</code>有了一个感性的了解，我们可以这样认为，<code>SOA</code>其实就是利用模块化思维，遵循<code>SOA</code>定义的原则构建分布式应用的架构模式，基于这个理解下面我们再来看一下在<code>SOA</code>架构下的实现方式。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><p><code>Web Service</code>相信大家对这个名词也不是很陌生吧，不过令人遗憾的是这个现在已经被滥用的太严重了，以至于我们不能清晰的描述出<code>Web Service</code>到底是什么。老规矩，根据维基百科定义<strong>Web服务是一种服务导向架构的技术，通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作。</strong> 其实，一般情况下可以认为<code>Web service</code> 是<code>SOA</code>架构的一个实例，通常使用HTTP协议，一般使用<code>web</code>服务器作为服务请求的管道。</p>
<ul>
<li><p><strong><code>Web Service</code>要素</strong></p>
<ul>
<li><p><code>SOAP</code><br>提到<code>Web Service</code>,不得不说到的就是<code>SOAP</code>了。<code>SOAP</code>（原为<code>Simple Object Access Protocol</code>的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，一个基于<code>XML</code>的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是<code>HTTP</code>或<code>HTTPS</code>，但也可能是<code>SMTP</code>或<code>XMPP</code>。</p>
</li>
<li><p><code>WSDL</code><br><code>WSDL (Web Service Description Language)</code>也遵循<code>XML</code>格式，用来描述哪个服务器提供什么服务，怎样找到它，以及该服务使用怎样的接口规范，简言之，服务发现。</p>
</li>
<li><code>UUID</code><br>一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务。</li>
</ul>
</li>
<li><p><strong>不同厂商的实现</strong><br>不同的厂商根据又发展了自己的协议和实现方式</p>
<ul>
<li>java<br><code>Java API for XML Web Services（JAX-WS）</code>是<code>Java</code>程序设计语言一个用来创建<code>Web</code>服务的<code>API</code></li>
<li>.NET<br>.<code>NET WebService</code>、<code>NET Remoting</code>、<code>WCF</code></li>
</ul>
</li>
<li><p><strong>Web Service 使用</strong><br>使用Web Service的过程变成，获得该服务的WSDL描述，根据WSDL构造一条格式化的SOAP请求发送给服务器，然后接收一条同样SOAP格式的应答，最后根据先前的WSDL解码数据。绝大多数情况下，请求和应答使用HTTP协议传输，那么发送请求就使用HTTP的POST方法。不过现在为了简化调用过程，又有了新的使用方式，就是舍弃一部分或者完全舍弃SOAP协议，使用HTTP+去掉头尾的SOAP或者HTTP+JSON的方式调实现web service,这种更加轻量的方式又叫做rest方式调用。</p>
</li>
</ul>
<h3 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h3><ul>
<li><strong>又又又来一个新名词</strong></li>
</ul>
<blockquote>
<p>REST（英文：Representational State Transfer，又称具象状态传输）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。说到底，REST也只是一种架构风格，而不是协议或标准。但这种新的风格对现有的以SOAP为代表的Web Service造成的冲击也是革命性的，因为它面向资源，甚至连服务也抽象成资源，它和HTTP紧密结合，是无状态的。</p>
</blockquote>
<p>传统意义上的rest可能要和soa划在一个层面，都是软件架构的方式，soa是面向服务的软件架构方式，Rest是面向资源的软件架构方式，不过事实上，一些Web Service提供者提供的REST API只有REST的外壳，传输的请求和应答全然是简化了的SOAP，这种新瓶装旧酒的做法只是加深了标准的分歧而已。归根结底REST无法简单地解决一些问题，因此我们只能看到SOAP在REST外壳下的借尸还魂。所以目前rest还是划分到webservice下的一个使用方式的分支，用以区分以soap为协议的传统webservice的调用方法。</p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="分布式异构系统的通信"><a href="#分布式异构系统的通信" class="headerlink" title="分布式异构系统的通信"></a>分布式异构系统的通信</h3><p>上面说到了SOA是构建模块化的分布式系统的架构模式，既然提到了分布式，那不得不说的就是基于分布式的模式下各个系统或者模块间的通信了。SOA建立在分布式和异构平台下，分布式程序的基础是RPC调用，RPC的本质是网络传输和对象序列化，需要用RPC在分布式和异构系统中进行通信。当然这只一种选择，还可以选择比如基于message的方式进行通讯和集成，这里就不展开说明了。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><blockquote>
<p>维基百科对于RPC的定义<br>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。</p>
</blockquote>
<ul>
<li><strong>RPC目标</strong><br>RPC的主要目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。</li>
<li><strong>RPC性能</strong><br>不过RPC是跨进程进行调用，如果在进程内进行方法调用，所需的时间量级是 ns（纳秒）级，而进程间的RPC方法调用时间量级通常是 ms（毫秒）级，它们之间有着10的六次方的效率之差，所以选择这只方式进行通讯意味着要要牺牲一定的性能，而且一般在这种架构下完成一个功能或者一个接口可能需要多次的RPC调用，这就要求我们在实现接口是特别注意性能问题，一点点的性能差异在这种架构下都会被放大。</li>
</ul>
<h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><h3 id="业界主流框架"><a href="#业界主流框架" class="headerlink" title="业界主流框架"></a>业界主流框架</h3><p>上面提到针对<code>SOA</code>的实现，各大厂商都提供了自己的技术实现和一整套的解决方案，但是在大规模异构的分布式系统中，还是希望能有一个比较统一的框架来实现各种异构系统的通信和集成，这个时候，就有了各种<code>RPC</code>框架，或者叫服务框架。一般分为两种，一种是比较狭义的<code>RPC</code>框架，属于轻量级框架，仅具备完整的<code>RPC</code>调用功能（比如像<code>thrift</code>、<code>gRPC</code>等），在各种复杂的架构和业务场景下，这种框架显得有些捉襟见肘，不具备比如调用监控、服务路由等功能。这时候，又衍生出了另外一种框架，分布式服务框架，包括<code>RPC</code>调用、服务治理、注册发现、流量切换、服务路由、多传输协议、多序列化协议等各种复杂的功能，使得<code>SOA</code>架构下的分布式系统具备高可用的能力。</p>
<h3 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h3><p><code>CORBAR</code>为了解决异构平台的<code>RPC</code>，使用了<code>IDL（Interface Definition Language）</code>来定义远程接口，并将其映射到特定的平台语言中。后来大部分的跨语言平台<code>RPC</code>基本都采用了此类方式，比如我们熟悉的<code>Web Service（SOAP）</code>，近年开源的 <code>Thrift</code>等。他们大部分都通过<code>IDL</code>定义，并提供工具来映射生成不同语言平台的<code>user-stub</code>和<code>server-stub</code>，并通过框架库来提供<code>RPCRuntime</code>的支持。不过貌似每个不同的<code>RPC</code>框架都定义了各自不同的<code>IDL</code>格式，导致程序员的学习成本进一步上升，<code>Web Service</code>尝试建立业界标准，无赖标准规范复杂而效率偏低，否则<code>Thrift</code>等更高效的<code>RPC</code>框架就没必要出现了。<code>IDL</code> 是为了跨平台语言实现<code>RPC</code>不得已的选择，要解决更广泛的问题自然导致了更复杂的方案。而对于同一平台内的 RPC 而言显然没必要搞个中间语言出来，例如<code>Java</code>原生的<code>RMI</code>，这样对于<code>java</code>程序员而言显得更直接简单，降低使用的学习成本。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mindwind/p/5518145.html" target="_blank" rel="external">http://www.cnblogs.com/mindwind/p/5518145.html</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84</a><br><a href="http://www.baike.com/wiki/SOA%E6%9E%B6%E6%9E%84" target="_blank" rel="external">http://www.baike.com/wiki/SOA%E6%9E%B6%E6%9E%84</a><br><a href="https://segmentfault.com/q/1010000003049016" target="_blank" rel="external">https://segmentfault.com/q/1010000003049016</a><br><a href="http://www.infoq.com/cn/articles/micro-soa-2?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">http://www.infoq.com/cn/articles/micro-soa-2?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link</a><br><a href="http://www.infoq.com/cn/articles/micro-soa-1?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">http://www.infoq.com/cn/articles/micro-soa-1?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link</a><br><a href="http://itindex.net/detail/51931-soa-api-%E5%88%86%E8%A3%82" target="_blank" rel="external">http://itindex.net/detail/51931-soa-api-%E5%88%86%E8%A3%82</a><br><a href="http://www.cnblogs.com/zhangz721/archive/2009/10/02/1577316.html" target="_blank" rel="external">http://www.cnblogs.com/zhangz721/archive/2009/10/02/1577316.html</a></p>
<p><strong> 如若在茫茫宇宙中窥见了一丝真理，那该是何等之幸事。</strong></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/24/%E6%9E%B6%E6%9E%84/SOA%E7%AE%80%E8%BF%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Servlet和JSP</title>
      <link>https://yanglukuan.github.io/2017/08/22/java/JSP%E5%92%8CServlet/</link>
      <guid>https://yanglukuan.github.io/2017/08/22/java/JSP%E5%92%8CServlet/</guid>
      <pubDate>Tue, 22 Aug 2017 05:07:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;在我们面试的时候一般会被问到，”Servlet和JSP有什么区别和联系？”。那么今天我们就来回答一下这个问题，顺便复习一下Servlet和JSP的一些相关知识。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;JSP&quot;&gt;&lt;a href=&quot;#JSP&quot; class=&quot;headerlink&quot; 
      
      </description>
      
      <content:encoded><![CDATA[<p>在我们面试的时候一般会被问到，”Servlet和JSP有什么区别和联系？”。那么今天我们就来回答一下这个问题，顺便复习一下Servlet和JSP的一些相关知识。</p>
<hr>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="出现"><a href="#出现" class="headerlink" title="出现"></a>出现</h3><blockquote>
<p>JSP（全称JavaServer Pages）是由Sun Microsystems公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成HTML、XML或其他格式文档的Web网页的技术标准。JSP技术是以Java语言作为脚本语言的，JSP网页为整个服务器端的Java库单元提供了一个接口来服务于HTTP的应用程序。从架构上说，JSP可以被看作是从Servlets高级提炼而作为JAVA Servlet 2.1 API的扩展而应用。Servlets和JSP最早都是由Sun Microsystems（太阳公司）开发的。</p>
</blockquote>
<p>随着大量的B/S架构程序开发出来以后，人们发现Servlet类的编写是非常繁琐的，主要集中在几个问题上：首先有大量冗余代码，这些代码在每个servlet类中都是一模一样或者基本近似的，其次是开发Servlet的程序员很少有精通美工的，导致使用Servlet开发无法方便的做到各种页面效果和丰富多彩的风格，这个时候sun借鉴了微软的ASP方式，正式提出JSP（也就是Servlet 1.1），JSP推出后，JAVA程序员也能象ASP的程序员那样将服务端代码添加在已经由美工设计好的静态页面上，经过一个JSP容器对JSP文件进行自动解析并转换成Servlet类来交给WEB服务器运行。这么一来，极大的提高了工作效率。</p>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>当客户端浏览器向服务器请求一个 JSP 页面时，服务器收到该请求后，首先检查所请求的这个JSP 文件内容 ( 代码 ) 是否已经被更新，或者是否是 JSP 文件创建后的第一次被访问，如果是，那么，这个 JSP 文件就会在服务器端的 JSP 引擎作用下转化为一个 Servlet 类的 Java 源代码文件。紧接着，这个 Servlet 类会在 Java 编译器的作用下被编译成一个字节码文件，并装载到 jvm 解释执行。剩下的就等同于 Servlet 的处理过程了。如果被请求的 JSP 文件内容 ( 代码 ) 没有被修改，那么它的处理过程也等同于一个 Servlet 的处理过程。即直接由服务器检索出与之对应的Servlet 实例来处理。一种是预编译，也就是当Tomcat启动的时候，所有部署的应用中的jsp都会进行编译，另外一种是当第一次访问的时候对该jsp进行编译；无论是哪一种，JSPCompilationContext都是编译的上下文，JSPServletWrapper通过JSPCompilationContext进行加载jsp源文件，然后调用对应的Compiler进行编译为servlet的class，并通过JasperLoader进行加载。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。最早支持Servlet标准的是JavaSoft的Java Web Server。此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p>
<h3 id="Servlet规范"><a href="#Servlet规范" class="headerlink" title="Servlet规范"></a>Servlet规范</h3><p><a href="http://ognvcf5x6.bkt.clouddn.com/bbs_image/Servlet3.1%E8%A7%84%E8%8C%83.pdf" target="_blank" rel="external">Servlet规范</a></p>
<h3 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h3><p>Servlet容器是web server或application server的一部分，提供基于请求/响应发送模型的网络服务，解码基于MIME的请求，并且格式化基于MIME的响应。Servlet 容器也包含了管理Servlet生命周期。Servlet容器可以嵌入到宿主的web server中，或者通过Web Server的本地扩展API单独作为附加组件安装。Servelt容器也可能内嵌或安装到包含web功能的application server中。所有Servlet容器必须支持基于HTTP协议的请求/响应模型，比如像基于HTTPS（HTTP over SSL）协议的请求/应答模型可以选择性的支持。容器必须实现的HTTP协议版本包含HTTP/1.0 和 HTTP/1.1。因为容器或许支持RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给Servlet处理之前修改它们，也可能在将Servlet生成的响应发送给客户端之前修改它们，或者可能根据RFC2616规范直接对请求作出响应而不交给Servlet进行处理。Servlet容器应该使Servlet执行在一个安全限制的环境中。在Java平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在Java平台定义的安全许可架构中。比如，高端的application server为了保证容器的其他组件不受到负面影响可能会限制Thread对象的创建。Java SE 6是构建Servlet容器最低的Java平台版本。</p>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>1、在servlet容器或web server启动时，对servlet进行实例化，此时调用servlet的构造方法；servlet实例化后，调用该servlet实例的init方法，对servlet进行一些初始化处理，处理完成后，将该servlet注入到servlet容器中;<br>2、当client向web server或servlet容器请求servlet时，web server或servlet容器首先会根据请求的servlet名称去servlet容器中找对应的servlet，如果servlet不存在该名称对应的servlet，则向client响应请求不存在等信息，否则进行步骤3；<br>3、如果请求的servlet存在于servlet容器，则调用servlet的service方法，生成动态资源，响应给client; （记住，整个过程该servlet只有一个实例，即单例）；<br>4、当web server退出或servlet容器销毁时，调用servlet的destroy方法，最后唯一的sevlet实例将会被GC。<br>在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的init()和destroy()方法都只进行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的service()方法，为接收到的请求服务。servlet只会实例化一次，servlet容器启动时或者第一次处理请求时之后所有请求都只共享这一个实例，每个请求对应一个线程去处理，线程池方式处理JSP/Servlet容器默认是采用单实例多线程(这是造成线程安全的主因)方式处理多个请求的。</p>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>由于servlet只会实例化一次，整个生命周期内所有的请求，都由这一个实例来完成，每个请求对应一个线程去处理，很容易造成线程安全性问题。<br>如果service()方法没有访问Servlet的成员变量也没有访问全局的资源比如静态变量、文件、数据库连接等，而是只使用了当前线程自己的资源，比如非指向全局资源的临时变量、request和response对象等。该方法本身就是线程安全的，不必进行任何的同步控制。<br>如果service()方法访问了Servlet的成员变量，但是对该变量的操作是只读操作，该方法本身就是线程安全的，不必进行任何的同步控制。<br>如果service()方法访问了Servlet的成员变量，并且对该变量的操作既有读又有写，通常需要加上同步控制语句。<br>如果service()方法访问了全局的静态变量，如果同一时刻系统中也可能有其它线程访问该静态变量，如果既有读也有写的操作，通常需要加上同步控制语句。<br>如果service()方法访问了全局的资源，比如文件、数据库连接等，通常需要加上同步控制语句。</p>
<h3 id="JSP本质上就是servlet"><a href="#JSP本质上就是servlet" class="headerlink" title="JSP本质上就是servlet"></a>JSP本质上就是servlet</h3><p>Java服务器页面（JSP）是HttpServlet的扩展。由于HttpServlet大多是用来响应HTTP请求，并返回Web页面（例如HTML、XML），所以不可避免地，在编写servlet时会涉及大量的HTML内容，这给servlet的书写效率和可读性带来很大障碍，JSP便是在这个基础上产生的。其功能是使用HTML的书写格式，在适当的地方加入Java代码片段，将程序员从复杂的HTML中解放出来，更专注于servlet本身的内容。JSP在首次被访问的时候被应用服务器转换为servlet，在以后的运行中，容器直接调用这个servlet，而不再访问JSP页面。<br>所以说JSP本质上就是servlet,在执行的时候最终会被编译成servlet。JSP加入了各种Web标签，使其能更加方便的编写动态Web应用程序。JSP 由 HTML 代码和 JSP 标签构成，可以方便地编写动态网页,Servlet完全是JAVA程序代码构成擅长于流程控制和事务处理.因此在实际应用中采用 Servlet 来控制业务流程,而采用 JSP 来生成动态网页.Servlet和JSP两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。</p>
<h2 id="容器和server"><a href="#容器和server" class="headerlink" title="容器和server"></a>容器和server</h2><h3 id="web-server"><a href="#web-server" class="headerlink" title="web server"></a>web server</h3><p>只要Web上的Server都叫Web Server，但是大家分工不同，解决的问题也不同，所以根据Web Server提供的功能，每个Web Server的名字也会不一样。按功能分类，Web Server可以分为：Http server和Application server。</p>
<h3 id="Http-server"><a href="#Http-server" class="headerlink" title="Http server"></a>Http server</h3><p>HTTP Server本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的IP地址并监听某一个tcp端口来接收并处理HTTP请求，这样客户端（一般来说是IE, Firefox，Chrome这样的浏览器）就能够通过HTTP协议来获取服务器上的网页（HTML格式）、文档（PDF格式）、音频（MP4格式）、视频（MOV格式）等等资源。HTTP Server中经常使用的是Apache、Nginx两种，HTTP Server主要用来做静态内容服务、代理服务器、负载均衡等。直面外来请求转发给后面的应用服务（Tomcat，django什么的）。</p>
<h3 id="Application-Server"><a href="#Application-Server" class="headerlink" title="Application Server"></a>Application Server</h3><p>Application Server 是一个应用执行的服务器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。与HTTP Server相比，Application Server能够动态的生成资源并返回到客户端。</p>
<blockquote>
<p>Application server可以作为servlet容器，tomcat、jeety等都是Application server都可以作为servlet容器。对于Tomcat来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以Application Server往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。</p>
<p>在实际运行的时候Java Servlet与Web服务器会融为一体，如同一个程序一样运行在同一个Java虚拟机（JVM）当中。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。另外因为Java Servlet是运行在虚拟机之上的，也就解决了跨平台问题。如果没有Servlet的出现，也就没有互联网的今天。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/xianggao/blog/670681" target="_blank" rel="external">https://my.oschina.net/xianggao/blog/670681</a><br><a href="http://www.hollischuang.com/archives/849" target="_blank" rel="external">http://www.hollischuang.com/archives/849</a><br><a href="http://developer.51cto.com/art/201012/237827.htm" target="_blank" rel="external">http://developer.51cto.com/art/201012/237827.htm</a><br><a href="http://www.10tiao.com/html/308/201609/2650076215/1.html" target="_blank" rel="external">http://www.10tiao.com/html/308/201609/2650076215/1.html</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/22/java/JSP%E5%92%8CServlet/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git多账号配置（Windows平台）</title>
      <link>https://yanglukuan.github.io/2017/08/21/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</link>
      <guid>https://yanglukuan.github.io/2017/08/21/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Mon, 21 Aug 2017 06:10:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;Git的配置相信大家都不陌生了，如果还不熟悉，不要着急，继续往下看就好了。今天主要看一下多账户的场景，顺便也复习一下Git的配置流程。  &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么情况下需要多账户的配置呢？&quot;&gt;&lt;a href=&quot;#什么情况下需要多账户的配置呢？&quot; class=
      
      </description>
      
      <content:encoded><![CDATA[<p>Git的配置相信大家都不陌生了，如果还不熟悉，不要着急，继续往下看就好了。今天主要看一下多账户的场景，顺便也复习一下Git的配置流程。  </p>
<hr>
<h2 id="什么情况下需要多账户的配置呢？"><a href="#什么情况下需要多账户的配置呢？" class="headerlink" title="什么情况下需要多账户的配置呢？"></a>什么情况下需要多账户的配置呢？</h2><p>1.在公司一般大家都会配置公司的代码仓库的账户，用的账号一般是公司企业邮箱账号,比如<code>zhangsan@XXX.com</code>,一般的配置流程都是企业入职的时候给一个配置清单或者新手指导，员工自己按照指导去配置，无非也就是用git的SSH 命令生成密钥对，然后将公钥上传至管理平台，就可以很开心的写Bug了，哦 不对，写码。<br>但是某一天有这样一个场景，有时候自己也会写点代码，这些代码一般我们托管在GitHub等平台上，这个时候就无法使用公司的账号了，需要再配置一个GitHub的账号，比如<code>zhangsan@Gmail.com</code>这样的账户名字。<br>2.由于天朝独特的网络环境,你们懂得，有时候GitHub无法连接或者不稳定，这个时候需要有一个国内的代码托管平台，国内比如码云这样的平台也可以托管代码，速度比较稳定。这个时候就需要同时配置GitHub和码云两个账户。</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><blockquote>
<p>公司账户和GitHub账户（不同邮箱）</p>
</blockquote>
<p>1.如果原来配置过一次，在用户目录下会有一个.ssh目录，里面存放着你默认第一次生成的秘钥对，<code>id_rsa</code>和<code>id_rsa.pub</code>,在此目录打开<code>Git bash</code> 输入命令 <code>ssh-keygen -C &quot;zhangsan@Gmail.com&quot; -t rsa</code> 然后回车 这个时候需要注意，需要给生成的秘钥对命名，比如<code>id_rsa_github</code>，不然会以默认的名字<code>id_rsa</code>生成，从而覆盖掉原来生成的。然后回车两次，就可以成功生成秘钥。<br>2.生成秘钥成功后，把生成公钥上传到GitHub的秘钥管理平台上，然后最重要的步骤来了。<br>回到用户目录的.ssh目录，创建一个config文本文件，注意这个文件名字为config，没有后缀名，尝试过加上.config后缀，貌似不会被识别。这个配置文件就是告诉ssh多个账户下，每个账户对应的秘钥位置和Host位置。<br>config配置文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># github </div><div class="line">Host github.com</div><div class="line">HostName github.com</div><div class="line">User zhangsan</div><div class="line">IdentityFile ~/.ssh/id_rsa_github</div><div class="line"></div><div class="line"># company</div><div class="line">Host code.company.com</div><div class="line">HostName code.company.com</div><div class="line">User zhangsan</div><div class="line">IdentityFile ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<p>这样配置就结束了，打开<code>git bash</code> 输入命令测试一下<br><code>ssh -T git@github.com</code><br>成功的话会收到这样一段回复<br><code>Hi zhangsan! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br>不成功的话，检查下上面的配置，或者使用<code>ssh -vT git@github.com</code>  查看下详细的错误信息。<br>3.有些网友的帖子会说如果配置了全局的Git用户名和邮箱，需要去掉，其实不去掉也是可以的。如果你先设置了公司的账户为全局配置，那么你克隆GitHub上的代码到本地后，只要在那个目录设置本地的用户名和邮箱，就可以了，因为本地的优先级要大于全局的设定，公司的代码目录则继续使用全局配置，一样的互不影响。</p>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><blockquote>
<p>GitHub和码云两个账号</p>
</blockquote>
<p>1.不同邮箱<br>如果你同时拥有GitHub和码云两个账号，而又不是使用同一邮箱注册，其实也类似于上面这张情况，分别生成不同邮箱的秘钥，然后再<code>config</code>文件里配置相应的用户、秘钥位置和<code>Host</code>就可以了。<br>2.相同邮箱<br>如果是相同的邮箱，就不需要上面的配置，只要用这个邮箱生成一次秘钥，这个秘钥可以同时用在两个网站上，两个远程仓库都可以提交，因为<code>SSH</code>秘钥是用邮箱生成的，邮箱相同，则秘钥也相同，所以可以共用一个。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/89cb26e5c3e8" target="_blank" rel="external">http://www.jianshu.com/p/89cb26e5c3e8</a><br><a href="https://gist.github.com/suziewong/4378434" target="_blank" rel="external">https://gist.github.com/suziewong/4378434</a><br><a href="http://noahsnail.com/2016/08/31/2016-9-1-Git%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">http://noahsnail.com/2016/08/31/2016-9-1-Git%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/</a><br><a href="https://steflerjiang.github.io/2016/12/16/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">https://steflerjiang.github.io/2016/12/16/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/21/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SonarQube 服务搭建与配置</title>
      <link>https://yanglukuan.github.io/2017/08/20/sonar%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/</link>
      <guid>https://yanglukuan.github.io/2017/08/20/sonar%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Sun, 20 Aug 2017 07:07:49 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;SonarQube是神马&quot;&gt;&lt;a href=&quot;#SonarQube是神马&quot; class=&quot;headerlink&quot; title=&quot;SonarQube是神马&quot;&gt;&lt;/a&gt;SonarQube是神马&lt;/h2&gt;&lt;p&gt;   1.&lt;code&gt;SonarQube（又叫Sonar）&lt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="SonarQube是神马"><a href="#SonarQube是神马" class="headerlink" title="SonarQube是神马"></a>SonarQube是神马</h2><p>   1.<code>SonarQube（又叫Sonar）</code>是对代码进行静态检测的开源平台,利用这个工具可以发现我们代码里各种隐藏的Bug和潜在的问     题，在团队协作的开发模式中可以更好的控制代码质量。<br>   2.支持多种平台<code>（Windows、Linux）</code>和多种开发语言<code>(java、C#、JavaScript、PHP等)</code>,并可以和<code>Jekins、JIRA</code>等多种外部工具和<code>IntelliJ IDEA</code>等开发工具无缝集成。<br>   3.可视化界面，提供各种维度的质量查询和分析。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h3><ul>
<li>下载软件<br><code>SonarQube</code> <a href="https://www.sonarqube.org/downloads/" target="_blank" rel="external">https://www.sonarqube.org/downloads/</a><br>规则插件 <code>checkstyle</code>  <a href="https://github.com/checkstyle/sonar-checkstyle" target="_blank" rel="external">https://github.com/checkstyle/sonar-checkstyle</a><br><code>pmd</code> <a href="https://github.com/SonarQubeCommunity/sonar-pmd" target="_blank" rel="external">https://github.com/SonarQubeCommunity/sonar-pmd</a><br><code>findbugs</code> <a href="https://github.com/SonarQubeCommunity/sonar-findbugs" target="_blank" rel="external">https://github.com/SonarQubeCommunity/sonar-findbugs</a><br>汉化插件 <code>sonar-l10n-zh-master</code> <a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh" target="_blank" rel="external">https://github.com/SonarQubeCommunity/sonar-l10n-zh</a><br>本地扫描插件 <code>sonar-runner-dist-2.4</code> <a href="http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.4/" target="_blank" rel="external">http://repo1.maven.org/maven2/org/codehaus/sonar/runner/sonar-runner-dist/2.4/</a><br><strong>以上插件均是源码 需要下载后自行编译</strong></li>
<li>所需环境<br><code>JDK1.7</code>或以上<br><code>Maven</code><br><code>Mysql</code></li>
<li><p>配置<br>a.<code>sonarqube\conf</code> 配置<br><code>sonar.properties</code>内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sonar.jdbc.username=sonar</div><div class="line">sonar.jdbc.password=sonar</div><div class="line">sonar.jdbc.url=jdbc:mysql://127.0.0.1:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</div></pre></td></tr></table></figure>
<p>b.mysql 配置</p>
<ul>
<li><p>在mysql管理器中执行如下脚本创建数据库及mysql用户  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> sonar <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;  </div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'sonar'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</div><div class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sonar.* <span class="keyword">TO</span> <span class="string">'sonar'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</div><div class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sonar.* <span class="keyword">TO</span> <span class="string">'sonar'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonar'</span>;</div><div class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><code>mysql max_allowed_packet</code>配置<br>路径 <code>C:\ProgramData\MySQL\MySQL Server 5.6\my.ini</code><br>设置 <code>max_allowed_packet=101943040</code></p>
</li>
</ul>
</li>
<li>插件编译 安装<br>分别编译下载的插件,去掉<code>snapshort</code>标记,放入插件目录下<code>sonarqube-6.4\extensions\plugins</code></li>
<li>启动<br>至此,启动mysql,启动<code>sonarqube</code>,本地访问 <code>http://localhost:9000/</code><br>可看到管理界面<br>登录名\密码   <code>admin\admin</code></li>
</ul>
<h3 id="扫描配置"><a href="#扫描配置" class="headerlink" title="扫描配置"></a><strong>扫描配置</strong></h3><ul>
<li><p><code>maven</code>扫描 配置<br><code>maven</code>配置文件添加节点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">activation</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.url</span>&gt;</span></div><div class="line">&lt;![CDATA[jdbc:mysql://127.0.0.1:3306/sonar]]&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">sonar.jdbc.url</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">sonar.jdbc.driver</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.username</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">sonar.jdbc.username</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.password</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">sonar.jdbc.password</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sonar.jdbc.maxWait</span>&gt;</span>50000<span class="tag">&lt;/<span class="name">sonar.jdbc.maxWait</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sonar.jdbc.minEvictableIdleTimeMillis</span>&gt;</span>600000<span class="tag">&lt;/<span class="name">sonar.jdbc.minEvictableIdleTimeMillis</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.jdbc.timeBetweenEvictionRunsMillis</span>&gt;</span>30000<span class="tag">&lt;/<span class="name">sonar.jdbc.timeBetweenEvictionRunsMillis</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span>http://localhost:9000<span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div></pre></td></tr></table></figure>
<p>执行maven命令<code>mvn sonar:sonar</code> 可扫描项目并上传质量报告</p>
</li>
<li><p><code>sonar-runner</code> 扫描配置<br>a.环境变量配置<br>系统环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SONAR_RUNNER_HOME  D:\Java\sonar-runner-2.4</div><div class="line">Path 追加 ;%SONAR_RUNNER_HOME%\bin;</div></pre></td></tr></table></figure>
<p>b.sonar-runner.properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#Configure here general information about the environment, such as SonarQube DB details for example</div><div class="line">#No information about specific project should appear here</div><div class="line">  </div><div class="line">#----- Default SonarQube server</div><div class="line">sonar.host.url=http://localhost:9000</div><div class="line">  </div><div class="line">#----- PostgreSQL</div><div class="line">#sonar.jdbc.url=jdbc:postgresql://localhost/sonar</div><div class="line">  </div><div class="line">#----- MySQL</div><div class="line">sonar.jdbc.url=jdbc:mysql://127.0.0.1:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8</div><div class="line">  </div><div class="line">#----- Oracle</div><div class="line">#sonar.jdbc.url=jdbc:oracle:thin:@localhost/XE</div><div class="line">  </div><div class="line">#----- Microsoft SQLServer</div><div class="line">#sonar.jdbc.url=jdbc:jtds:sqlserver://localhost/sonar;SelectMethod=Cursor</div><div class="line">  </div><div class="line">#----- Global database settings</div><div class="line">sonar.jdbc.username=sonar</div><div class="line">sonar.jdbc.password=sonar</div><div class="line">  </div><div class="line">#----- Default source code encoding</div><div class="line">sonar.sourceEncoding=UTF-8</div><div class="line">  </div><div class="line">#----- Security (when 'sonar.forceAuthentication' is set to 'true')</div><div class="line">sonar.login=admin</div><div class="line">sonar.password=admin</div></pre></td></tr></table></figure>
<p>c、本地项目配置文件  项目根目录<br>sonar-project.properties配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sonar.projectKey=projectKey </div><div class="line">sonar.projectName=projectName</div><div class="line">sonar.projectVersion=1.0</div><div class="line"># Set modules IDs</div><div class="line">sonar.modules=projectmodules</div><div class="line"></div><div class="line"># Modules inherit properties set at parent level</div><div class="line">sonar.sources=src</div><div class="line">sonar.sourceEncoding=UTF-8</div><div class="line">sonar.language=java</div><div class="line">sonar.java.binaries=target</div><div class="line"># By default, the base directory for a module is <span class="tag">&lt;<span class="name">current_dir</span>&gt;</span>/<span class="tag">&lt;<span class="name">module_ID</span>&gt;</span>.</div></pre></td></tr></table></figure>
<p>至此  使用命令行进入到项目根目录<br>输入命令 <code>sonar-runner</code> 可以完成项目的扫描和上传报告  </p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/22926742" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22926742</a><br><a href="http://blog.csdn.net/xiajian2010/article/details/22983825" target="_blank" rel="external">http://blog.csdn.net/xiajian2010/article/details/22983825</a><br><a href="http://www.cnblogs.com/parryyang/p/6270402.html" target="_blank" rel="external">http://www.cnblogs.com/parryyang/p/6270402.html</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/20/sonar%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo+GitHub Pages博客搭建</title>
      <link>https://yanglukuan.github.io/2017/08/17/firstblog/</link>
      <guid>https://yanglukuan.github.io/2017/08/17/firstblog/</guid>
      <pubDate>Thu, 17 Aug 2017 06:56:25 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;闲扯一会&quot;&gt;&lt;a href=&quot;#闲扯一会&quot; class=&quot;headerlink&quot; title=&quot;闲扯一会&quot;&gt;&lt;/a&gt;闲扯一会&lt;/h2&gt;&lt;p&gt;生命不息，学习不止。最近读了不少书和博客,但是读下来发现了一些问题。比如，有些知识点看过很多次，每次看的时候都觉得似曾相识，
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="闲扯一会"><a href="#闲扯一会" class="headerlink" title="闲扯一会"></a>闲扯一会</h2><p>生命不息，学习不止。最近读了不少书和博客,但是读下来发现了一些问题。比如，有些知识点看过很多次，每次看的时候都觉得似曾相识，却又记不起全貌。有些则是过目就忘，合上书本完全不记得书中所讲精要，甚是苦闷。这几日忽得夫人点拨，说是输出倒逼输入，意思就是充当别人的老师，然后逼自己学习更多的知识。这个道理大家自然都是懂得，只不过有时候做起来比较难以实践。一个是因为人都有惰性，好多事情都是停留在思想和嘴巴，付诸行动的少之又少。再者，也不太容易有机会充当别人的老师，而且本身我自己也不是那种好为人师的性格，倒不是清高装逼，也是怕误人子弟。<br>不过我们这个行业比较特殊，可以有很好的方式去做输出倒逼输入的事情，比如写博客。其实很早就注册了博客园，但是到现在也只是酱油和灌水，没有发过帖子。现在决定写博客，把自己的输入真正变成自己的东西，一方面在写的过程中梳理一下知识，另一方面也记录下自己解决过的问题、踩过的坑。博客前期打算以Step By Step的教程为主，主要为了熟悉markdown语法和Hexo博客的使用，后面会慢慢转向原理解析类和日常踩坑记录类。<br><strong>往者不可谏,来者犹可追。</strong></p>
<hr>
<h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h3 id="GitHub-Pages-设置"><a href="#GitHub-Pages-设置" class="headerlink" title="GitHub Pages 设置"></a>GitHub Pages 设置</h3><p>   Github Pages 是 Github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制，还可以绑定自己的域名。在 <a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a> 首页上可以看到很多用 Github Pages 托管的网站，很漂亮。另外很多非常著名的公司和项目也都用这种方式来搭建网站，如微软和 twitter 的网站，还有 谷歌的 Material Design 图标 网站。本博客就是利用Github Pages托管所建。开始创建自己的网站：<br>   创建一个新的仓库  <code>yourname.github.io</code>，<code>yourname</code> 就是你github的用户名，不可以是其他字符，不然访问不到。<br>   只要把静态的网站文件上传到这个仓库，然后访问<code>https://yourname.github.io</code>，就可以看到自己的网站了。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>   Hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。<br>   所需环境<br>   Nodejs<br>   Git</p>
<p>1.首先安装好Nodejs和Git,Hexo安装过程中，有些文件是通过Git下载下来。<br>安装cnpm 由于天朝网路环境问题，所以最好安装cnpm 淘宝的镜像，下载比较快<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>全局安装hexo<br><code>cnpm install hexo-cli -g</code><br>新建一个hexo/blog文件夹<br>进入到你的hexo/blog目录<br>打开git bash<br><code>cnpm install hexo --save</code><br>检查是否安装成功<br><code>hexo -v</code><br>初始化Hexo<br><code>hexo init</code><br>这里会创建一些文件<br>然后输入<br><code>cnpm install</code><br>这里要等一会，安装组件</p>
<p>2.然后就可以使用了<br>常用命令<br><code>hexo new &quot;Hello World&quot;</code> 创建新页面<br><code>hexo generate</code> 重新生成所有页面<br><code>hexo server</code> 启动本地预览  预览地址 <code>http://localhost:4000</code><br> 会看到一个默认主题的hexo网站。</p>
<p> <code>hexo new</code> 命令会创建一个md格式的文件，就是我们写博客的文件，推荐使用markdownpad来写，支持各种markdown格式，<br> 其实在使用过程中无需使用此命令创建，只要在blog下的<code>\source\_posts</code>文件夹下直接新建md格式的文件就可以了。Hexo在生成博客的时候回自动识别这个目录下写所有md文件。</p>
<p>3.发布到GitHub<br> 找到blog目录下的<code>_config.yml</code>文件，加入以下节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type: git</div><div class="line">repo:</div><div class="line">  github: &lt;repository url&gt;,[branch]</div></pre></td></tr></table></figure></p>
<p>执行命令<br>hexo d 就可以完成发布，发布成功后，就可以在<code>https://yourname.github.io</code>看到自己更新的内容了，由于CDN缓存的缘故，有时候更新后要过一会才可以看到最新的内容。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>   <a href="http://theme-next.iissnan.com/getting-started.html#theme-settings" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html#theme-settings</a><br>   <a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a><br>   <a href="http://gitbeijing.com/pages.html" target="_blank" rel="external">http://gitbeijing.com/pages.html</a><br>   <a href="http://www.jianshu.com/p/b8dd1e3e0255" target="_blank" rel="external">http://www.jianshu.com/p/b8dd1e3e0255</a></p>
]]></content:encoded>
      
      <comments>https://yanglukuan.github.io/2017/08/17/firstblog/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
